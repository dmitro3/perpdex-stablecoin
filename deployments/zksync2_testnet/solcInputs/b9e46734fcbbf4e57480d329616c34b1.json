{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\n\ninterface IERC20Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/PerpdexTokenBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { Multicall } from \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { IPerpdexExchange } from \"../deps/perpdex-contract/contracts/interfaces/IPerpdexExchange.sol\";\nimport { IPerpdexMarket } from \"../deps/perpdex-contract/contracts/interfaces/IPerpdexMarket.sol\";\nimport { IWETH9 } from \"../deps/perpdex-contract/contracts/interfaces/external/IWETH9.sol\";\nimport { IERC4626 } from \"./interfaces/IERC4626.sol\";\nimport { IERC20Metadata } from \"./interfaces/IERC20Metadata.sol\";\n\nabstract contract PerpdexTokenBase is IERC4626, ReentrancyGuard, Multicall, ERC20, ERC20Permit {\n    using SafeCast for int256;\n\n    address public immutable override asset;\n    address public immutable market;\n    address public immutable exchange;\n    address public immutable weth;\n\n    uint8 private constant DECIMALS = 18;\n\n    modifier onlyWeth() {\n        require(weth != address(0), \"PTB_OW: weth is not available\");\n        _;\n    }\n\n    constructor(\n        address marketArg,\n        string memory namePrefix,\n        string memory symbolPrefix,\n        string memory nativeTokenSymbol,\n        address wethArg\n    )\n        ERC20(\n            _getERC20Name(marketArg, namePrefix, nativeTokenSymbol),\n            _getERC20Name(marketArg, symbolPrefix, nativeTokenSymbol)\n        )\n        ERC20Permit(_getERC20Name(marketArg, namePrefix, nativeTokenSymbol))\n    {\n        address exchangeVar = IPerpdexMarket(marketArg).exchange();\n        address settlementToken = IPerpdexExchange(exchangeVar).settlementToken();\n        address assetVar;\n\n        require(IPerpdexExchange(exchangeVar).quoteDecimals() == DECIMALS, \"PTB_C: invalid decimals\");\n\n        if (settlementToken == address(0)) {\n            require(wethArg != address(0), \"PTB_C: weth is required\");\n            assetVar = wethArg;\n        } else {\n            require(wethArg == address(0), \"PTB_C: weth can not be used\");\n            assetVar = settlementToken;\n        }\n\n        asset = assetVar;\n        market = marketArg;\n        weth = wethArg;\n        exchange = exchangeVar;\n    }\n\n    receive() external payable {}\n\n    // make ERC20 external functions non reentrant\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override nonReentrant {\n        ERC20Permit.permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    function transfer(address recipient, uint256 amount) public override nonReentrant returns (bool) {\n        return ERC20.transfer(recipient, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override nonReentrant returns (bool) {\n        return ERC20.approve(spender, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override nonReentrant returns (bool) {\n        return ERC20.transferFrom(sender, recipient, amount);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public override nonReentrant returns (bool) {\n        return ERC20.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override nonReentrant returns (bool) {\n        return ERC20.decreaseAllowance(spender, subtractedValue);\n    }\n\n    // ERC4626\n\n    function totalAssets() public view override returns (uint256 totalManagedAssets) {\n        int256 value = IPerpdexExchange(exchange).getTotalAccountValue(address(this));\n        totalManagedAssets = value < 0 ? 0 : _convertToAssetDecimals(uint256(value));\n    }\n\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return\n                Math.mulDiv(\n                    _convertToPerpdexDecimals(assets),\n                    FixedPoint96.Q96,\n                    IPerpdexMarket(market).getShareMarkPriceX96()\n                );\n        }\n        return Math.mulDiv(assets, supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return\n                Math.mulDiv(\n                    _convertToAssetDecimals(shares),\n                    IPerpdexMarket(market).getShareMarkPriceX96(),\n                    FixedPoint96.Q96\n                );\n        }\n        return Math.mulDiv(shares, totalAssets(), supply);\n    }\n\n    function _convertToPerpdexDecimals(uint256 amount) internal view returns (uint256 assets) {\n        return Math.mulDiv(amount, 10**DECIMALS, 10**IERC20Metadata(asset).decimals());\n    }\n\n    function _convertToAssetDecimals(uint256 amount) internal view returns (uint256 assets) {\n        return Math.mulDiv(amount, 10**IERC20Metadata(asset).decimals(), 10**DECIMALS);\n    }\n\n    function _beforeTrade(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount\n    ) private view returns (uint256) {\n        if (isBaseToQuote) {\n            if (!isExactInput) {\n                return _convertToPerpdexDecimals(amount);\n            }\n        } else {\n            if (isExactInput) {\n                return _convertToPerpdexDecimals(amount);\n            }\n        }\n        return amount;\n    }\n\n    function _afterTrade(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount\n    ) private view returns (uint256) {\n        if (isBaseToQuote) {\n            if (isExactInput) {\n                return _convertToAssetDecimals(amount);\n            }\n        } else {\n            if (!isExactInput) {\n                return _convertToAssetDecimals(amount);\n            }\n        }\n        return amount;\n    }\n\n    function _maxTrade(bool isBaseToQuote, bool isExactInput) internal view returns (uint256 maxAmount) {\n        maxAmount = IPerpdexExchange(exchange).maxTrade(\n            IPerpdexExchange.MaxTradeParams({\n                trader: address(this),\n                market: market,\n                caller: address(this),\n                isBaseToQuote: isBaseToQuote,\n                isExactInput: isExactInput\n            })\n        );\n\n        maxAmount = _afterTrade(isBaseToQuote, isExactInput, maxAmount);\n    }\n\n    function _tryPreviewTrade(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount\n    ) internal view returns (bool success, uint256 oppositeAmount) {\n        amount = _beforeTrade(isBaseToQuote, isExactInput, amount);\n        try\n            IPerpdexExchange(exchange).previewTrade(\n                IPerpdexExchange.PreviewTradeParams({\n                    trader: address(this),\n                    market: market,\n                    caller: address(this),\n                    isBaseToQuote: isBaseToQuote,\n                    isExactInput: isExactInput,\n                    amount: amount,\n                    oppositeAmountBound: isExactInput ? 0 : type(uint256).max\n                })\n            )\n        returns (uint256 v) {\n            success = true;\n            oppositeAmount = _afterTrade(isBaseToQuote, isExactInput, v);\n        } catch {}\n    }\n\n    function _previewTrade(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount\n    ) internal view returns (uint256 oppositeAmount) {\n        amount = _beforeTrade(isBaseToQuote, isExactInput, amount);\n        oppositeAmount = IPerpdexExchange(exchange).previewTrade(\n            IPerpdexExchange.PreviewTradeParams({\n                trader: address(this),\n                market: market,\n                caller: address(this),\n                isBaseToQuote: isBaseToQuote,\n                isExactInput: isExactInput,\n                amount: amount,\n                oppositeAmountBound: isExactInput ? 0 : type(uint256).max\n            })\n        );\n        oppositeAmount = _afterTrade(isBaseToQuote, isExactInput, oppositeAmount);\n    }\n\n    function _trade(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount\n    ) internal returns (uint256 oppositeAmount) {\n        amount = _beforeTrade(isBaseToQuote, isExactInput, amount);\n        oppositeAmount = IPerpdexExchange(exchange).trade(\n            IPerpdexExchange.TradeParams({\n                trader: address(this),\n                market: market,\n                isBaseToQuote: isBaseToQuote,\n                isExactInput: isExactInput,\n                amount: amount,\n                oppositeAmountBound: isExactInput ? 0 : type(uint256).max,\n                deadline: type(uint256).max\n            })\n        );\n        oppositeAmount = _afterTrade(isBaseToQuote, isExactInput, oppositeAmount);\n    }\n\n    function _depositToPerpdex(uint256 amount) internal {\n        if (weth == address(0)) {\n            IERC20(asset).approve(exchange, type(uint256).max);\n            IPerpdexExchange(exchange).deposit(amount);\n        } else {\n            IPerpdexExchange(exchange).deposit{ value: amount }(0);\n        }\n    }\n\n    function _withdrawFromPerpdex(uint256 amount) internal {\n        IPerpdexExchange(exchange).withdraw(_convertToPerpdexDecimals(amount));\n    }\n\n    function _transferAssetTo(address to, uint256 amount) internal {\n        if (weth != address(0)) {\n            IWETH9(weth).deposit{ value: amount }();\n        }\n        SafeERC20.safeTransfer(IERC20(asset), to, amount);\n    }\n\n    function _transferAssetFromSender(uint256 amount) internal {\n        address from = msg.sender;\n        address to = address(this);\n        SafeERC20.safeTransferFrom(IERC20(asset), from, to, amount);\n        if (weth != address(0)) {\n            IWETH9(weth).withdraw(amount);\n        }\n    }\n\n    function _getERC20Name(\n        address marketArg,\n        string memory prefix,\n        string memory nativeTokenSymbol\n    ) private view returns (string memory) {\n        address settlementToken = IPerpdexExchange(IPerpdexMarket(marketArg).exchange()).settlementToken();\n\n        return\n            string(\n                abi.encodePacked(\n                    prefix,\n                    IPerpdexMarket(marketArg).symbol(),\n                    settlementToken == address(0) ? nativeTokenSymbol : IERC20Metadata(settlementToken).symbol()\n                )\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` â†’ `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "deps/perpdex-contract/contracts/interfaces/IPerpdexExchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { PerpdexStructs } from \"../lib/PerpdexStructs.sol\";\n\ninterface IPerpdexExchange {\n    struct AddLiquidityParams {\n        address market;\n        uint256 base;\n        uint256 quote;\n        uint256 minBase;\n        uint256 minQuote;\n        uint256 deadline;\n    }\n\n    struct RemoveLiquidityParams {\n        address trader;\n        address market;\n        uint256 liquidity;\n        uint256 minBase;\n        uint256 minQuote;\n        uint256 deadline;\n    }\n\n    struct TradeParams {\n        address trader;\n        address market;\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amount;\n        uint256 oppositeAmountBound;\n        uint256 deadline;\n    }\n\n    struct PreviewTradeParams {\n        address trader;\n        address market;\n        address caller;\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amount;\n        uint256 oppositeAmountBound;\n    }\n\n    struct MaxTradeParams {\n        address trader;\n        address market;\n        address caller;\n        bool isBaseToQuote;\n        bool isExactInput;\n    }\n\n    struct CreateLimitOrderParams {\n        address market;\n        bool isBid;\n        uint256 base;\n        uint256 priceX96;\n        uint256 deadline;\n    }\n\n    struct CancelLimitOrderParams {\n        address market;\n        bool isBid;\n        uint40 orderId;\n        uint256 deadline;\n    }\n\n    event CollateralCompensated(address indexed trader, uint256 amount);\n    event Deposited(address indexed trader, uint256 amount);\n    event Withdrawn(address indexed trader, uint256 amount);\n    event ProtocolFeeTransferred(address indexed trader, uint256 amount);\n\n    event LiquidityAdded(\n        address indexed trader,\n        address indexed market,\n        uint256 base,\n        uint256 quote,\n        uint256 liquidity,\n        uint256 cumBasePerLiquidityX96,\n        uint256 cumQuotePerLiquidityX96\n    );\n\n    event LiquidityRemoved(\n        address indexed trader,\n        address indexed market,\n        address liquidator,\n        uint256 base,\n        uint256 quote,\n        uint256 liquidity,\n        int256 takerBase,\n        int256 takerQuote,\n        int256 realizedPnl\n    );\n\n    event PartiallyExecuted(\n        address indexed maker,\n        address indexed market,\n        bool isAsk,\n        uint256 basePartial,\n        uint256 quotePartial,\n        int256 partialRealizedPnL\n    );\n\n    event PositionLiquidated(\n        address indexed trader,\n        address indexed market,\n        address indexed liquidator,\n        int256 base,\n        int256 quote,\n        int256 realizedPnl,\n        uint256 protocolFee,\n        uint256 baseBalancePerShareX96,\n        uint256 sharePriceAfterX96,\n        uint256 liquidationPenalty,\n        uint256 liquidationReward,\n        uint256 insuranceFundReward\n    );\n\n    event PositionChanged(\n        address indexed trader,\n        address indexed market,\n        int256 base,\n        int256 quote,\n        int256 realizedPnl,\n        uint256 protocolFee,\n        uint256 baseBalancePerShareX96,\n        uint256 sharePriceAfterX96\n    );\n\n    event LimitOrderCreated(\n        address indexed trader,\n        address indexed market,\n        bool isBid,\n        uint256 base,\n        uint256 priceX96,\n        uint256 orderId\n    );\n\n    event LimitOrderCanceled(\n        address indexed trader,\n        address indexed market,\n        address indexed liquidator,\n        bool isBid,\n        uint256 orderId\n    );\n\n    event MaxMarketsPerAccountChanged(uint8 value);\n    event MaxOrdersPerAccountChanged(uint8 value);\n    event ImRatioChanged(uint24 value);\n    event MmRatioChanged(uint24 value);\n    event LiquidationRewardConfigChanged(uint24 rewardRatio, uint16 smoothEmaTime);\n    event ProtocolFeeRatioChanged(uint24 value);\n    event IsMarketAllowedChanged(address indexed market, bool isMarketAllowed);\n\n    function deposit(uint256 amount) external payable;\n\n    function withdraw(uint256 amount) external;\n\n    function transferProtocolFee(uint256 amount) external;\n\n    function addLiquidity(AddLiquidityParams calldata params)\n        external\n        returns (\n            uint256 base,\n            uint256 quote,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(RemoveLiquidityParams calldata params) external returns (uint256 base, uint256 quote);\n\n    function createLimitOrder(CreateLimitOrderParams calldata params) external returns (uint40 orderId);\n\n    function cancelLimitOrder(CancelLimitOrderParams calldata params) external;\n\n    function trade(TradeParams calldata params) external returns (uint256 oppositeAmount);\n\n    // setters\n\n    function setMaxMarketsPerAccount(uint8 value) external;\n\n    function setImRatio(uint24 value) external;\n\n    function setMmRatio(uint24 value) external;\n\n    function setLiquidationRewardConfig(PerpdexStructs.LiquidationRewardConfig calldata value) external;\n\n    function setProtocolFeeRatio(uint24 value) external;\n\n    function setIsMarketAllowed(address market, bool value) external;\n\n    // dry run getters\n\n    function previewTrade(PreviewTradeParams calldata params) external view returns (uint256 oppositeAmount);\n\n    function maxTrade(MaxTradeParams calldata params) external view returns (uint256 amount);\n\n    // default getters\n\n    function accountInfos(address trader)\n        external\n        view\n        returns (PerpdexStructs.VaultInfo memory, uint8 limitOrderCount);\n\n    function insuranceFundInfo() external view returns (uint256 balance, uint256 liquidationRewardBalance);\n\n    function protocolInfo() external view returns (uint256 protocolFee);\n\n    function settlementToken() external view returns (address);\n\n    function quoteDecimals() external view returns (uint8);\n\n    function maxMarketsPerAccount() external view returns (uint8);\n\n    function imRatio() external view returns (uint24);\n\n    function mmRatio() external view returns (uint24);\n\n    function liquidationRewardConfig() external view returns (uint24 rewardRatio, uint16 smoothEmaTime);\n\n    function protocolFeeRatio() external view returns (uint24);\n\n    function isMarketAllowed(address market) external view returns (bool);\n\n    // getters not covered by default getters\n\n    function getTakerInfo(address trader, address market) external view returns (PerpdexStructs.TakerInfo memory);\n\n    function getMakerInfo(address trader, address market) external view returns (PerpdexStructs.MakerInfo memory);\n\n    function getAccountMarkets(address trader) external view returns (address[] memory);\n\n    // convenient getters\n\n    function getTotalAccountValue(address trader) external view returns (int256);\n\n    function getPositionShare(address trader, address market) external view returns (int256);\n\n    function getPositionNotional(address trader, address market) external view returns (int256);\n\n    function getTotalPositionNotional(address trader) external view returns (uint256);\n\n    function getOpenPositionShare(address trader, address market) external view returns (uint256);\n\n    function getOpenPositionNotional(address trader, address market) external view returns (uint256);\n\n    function getTotalOpenPositionNotional(address trader) external view returns (uint256);\n\n    function hasEnoughMaintenanceMargin(address trader) external view returns (bool);\n\n    function hasEnoughInitialMargin(address trader) external view returns (bool);\n\n    function isLiquidationFree(address trader) external view returns (bool);\n}\n"
    },
    "deps/perpdex-contract/contracts/interfaces/IPerpdexMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { IPerpdexMarketMinimum } from \"./IPerpdexMarketMinimum.sol\";\n\ninterface IPerpdexMarket is IPerpdexMarketMinimum {\n    event FundingPaid(\n        int256 fundingRateX96,\n        uint32 elapsedSec,\n        int256 premiumX96,\n        uint256 markPriceX96,\n        uint256 cumBasePerLiquidityX96,\n        uint256 cumQuotePerLiquidityX96\n    );\n    event LiquidityAdded(uint256 base, uint256 quote, uint256 liquidity);\n    event LiquidityRemoved(uint256 base, uint256 quote, uint256 liquidity);\n    event Swapped(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        uint256 oppositeAmount,\n        uint40 fullLastOrderId,\n        uint40 partialOrderId,\n        uint256 basePartial,\n        uint256 quotePartial\n    );\n    event LimitOrderCreated(bool isBid, uint256 base, uint256 priceX96, uint256 orderId);\n    event LimitOrderCanceled(bool isBid, uint256 orderId);\n\n    // getters\n\n    function symbol() external view returns (string memory);\n\n    function getMarkPriceX96() external view returns (uint256);\n}\n"
    },
    "deps/perpdex-contract/contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.7.6;\n\n// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    function asset() external view returns (address assetTokenAddress);\n\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n Ã· 2 + 1, and for v in (302): v âˆˆ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/PerpdexStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\n\nimport {\n    BokkyPooBahsRedBlackTreeLibrary as RBTreeLibrary\n} from \"../../deps/BokkyPooBahsRedBlackTreeLibrary/contracts/BokkyPooBahsRedBlackTreeLibrary.sol\";\n\nlibrary PerpdexStructs {\n    struct TakerInfo {\n        int256 baseBalanceShare;\n        int256 quoteBalance;\n    }\n\n    struct MakerInfo {\n        uint256 liquidity;\n        uint256 cumBaseSharePerLiquidityX96;\n        uint256 cumQuotePerLiquidityX96;\n    }\n\n    struct LimitOrderInfo {\n        RBTreeLibrary.Tree ask;\n        RBTreeLibrary.Tree bid;\n        uint256 totalBaseAsk;\n        uint256 totalBaseBid;\n    }\n\n    struct VaultInfo {\n        int256 collateralBalance;\n    }\n\n    struct AccountInfo {\n        // market\n        mapping(address => TakerInfo) takerInfos;\n        // market\n        mapping(address => MakerInfo) makerInfos;\n        // market\n        mapping(address => LimitOrderInfo) limitOrderInfos;\n        VaultInfo vaultInfo;\n        address[] markets;\n        uint8 limitOrderCount;\n    }\n\n    struct InsuranceFundInfo {\n        uint256 balance; // for easy calculation\n        uint256 liquidationRewardBalance;\n    }\n\n    struct ProtocolInfo {\n        uint256 protocolFee;\n    }\n\n    struct LiquidationRewardConfig {\n        uint24 rewardRatio;\n        uint16 smoothEmaTime;\n    }\n}\n"
    },
    "deps/perpdex-contract/deps/BokkyPooBahsRedBlackTreeLibrary/contracts/BokkyPooBahsRedBlackTreeLibrary.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's Red-Black Tree Library v1.0-pre-release-a\n//\n// A Solidity Red-Black Tree binary search library to store and access a sorted\n// list of unsigned integer data. The Red-Black algorithm rebalances the binary\n// search tree, resulting in O(log n) insert, remove and search time (and ~gas)\n//\n// https://github.com/bokkypoobah/BokkyPooBahsRedBlackTreeLibrary\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2020. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsRedBlackTreeLibrary {\n    struct Node {\n        uint40 parent;\n        uint40 left;\n        uint40 right;\n        bool red;\n        uint128 userData; // use freely. this is for gas efficiency\n    }\n\n    struct Tree {\n        uint40 root;\n        mapping(uint40 => Node) nodes;\n    }\n\n    uint40 private constant EMPTY = 0;\n\n    function first(Tree storage self) internal view returns (uint40 _key) {\n        _key = self.root;\n        if (_key != EMPTY) {\n            _key = treeMinimum(self, self.root);\n        }\n    }\n\n    function last(Tree storage self) internal view returns (uint40 _key) {\n        _key = self.root;\n        if (_key != EMPTY) {\n            _key = treeMaximum(self, self.root);\n        }\n    }\n\n    function next(Tree storage self, uint40 target)\n        internal\n        view\n        returns (uint40 cursor)\n    {\n        require(target != EMPTY, \"RBTL_N: target is empty\");\n        if (self.nodes[target].right != EMPTY) {\n            cursor = treeMinimum(self, self.nodes[target].right);\n        } else {\n            cursor = self.nodes[target].parent;\n            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n                target = cursor;\n                cursor = self.nodes[cursor].parent;\n            }\n        }\n    }\n\n    function prev(Tree storage self, uint40 target)\n        internal\n        view\n        returns (uint40 cursor)\n    {\n        require(target != EMPTY, \"RBTL_P: target is empty\");\n        if (self.nodes[target].left != EMPTY) {\n            cursor = treeMaximum(self, self.nodes[target].left);\n        } else {\n            cursor = self.nodes[target].parent;\n            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n                target = cursor;\n                cursor = self.nodes[cursor].parent;\n            }\n        }\n    }\n\n    function exists(Tree storage self, uint40 key)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            (key != EMPTY) &&\n            ((key == self.root) || (self.nodes[key].parent != EMPTY));\n    }\n\n    function isEmpty(uint40 key) internal pure returns (bool) {\n        return key == EMPTY;\n    }\n\n    function getEmpty() internal pure returns (uint256) {\n        return EMPTY;\n    }\n\n    function getNode(Tree storage self, uint40 key)\n        internal\n        view\n        returns (\n            uint40 _returnKey,\n            uint40 _parent,\n            uint40 _left,\n            uint40 _right,\n            bool _red\n        )\n    {\n        require(exists(self, key), \"RBTL_GN: key not exist\");\n        return (\n            key,\n            self.nodes[key].parent,\n            self.nodes[key].left,\n            self.nodes[key].right,\n            self.nodes[key].red\n        );\n    }\n\n    function insert(\n        Tree storage self,\n        uint40 key,\n        uint128 userData,\n        function(uint40, uint40, uint256) view returns (bool) lessThan,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) internal {\n        require(key != EMPTY, \"RBTL_I: key is empty\");\n        require(!exists(self, key), \"RBTL_I: key already exists\");\n        uint40 cursor = EMPTY;\n        uint40 probe = self.root;\n        self.nodes[key] = Node({\n            parent: EMPTY,\n            left: EMPTY,\n            right: EMPTY,\n            red: true,\n            userData: userData\n        });\n        while (probe != EMPTY) {\n            cursor = probe;\n            if (lessThan(key, probe, data)) {\n                probe = self.nodes[probe].left;\n            } else {\n                probe = self.nodes[probe].right;\n            }\n        }\n        self.nodes[key].parent = cursor;\n        if (cursor == EMPTY) {\n            self.root = key;\n        } else if (lessThan(key, cursor, data)) {\n            self.nodes[cursor].left = key;\n        } else {\n            self.nodes[cursor].right = key;\n        }\n        aggregateRecursively(self, key, aggregate, data);\n        insertFixup(self, key, aggregate, data);\n    }\n\n    function remove(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) internal {\n        require(key != EMPTY, \"RBTL_R: key is empty\");\n        require(exists(self, key), \"RBTL_R: key not exist\");\n        uint40 probe;\n        uint40 cursor;\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\n            cursor = key;\n        } else {\n            cursor = self.nodes[key].right;\n            while (self.nodes[cursor].left != EMPTY) {\n                cursor = self.nodes[cursor].left;\n            }\n        }\n        if (self.nodes[cursor].left != EMPTY) {\n            probe = self.nodes[cursor].left;\n        } else {\n            probe = self.nodes[cursor].right;\n        }\n        uint40 yParent = self.nodes[cursor].parent;\n        self.nodes[probe].parent = yParent;\n        if (yParent != EMPTY) {\n            if (cursor == self.nodes[yParent].left) {\n                self.nodes[yParent].left = probe;\n            } else {\n                self.nodes[yParent].right = probe;\n            }\n        } else {\n            self.root = probe;\n        }\n        bool doFixup = !self.nodes[cursor].red;\n        if (cursor != key) {\n            replaceParent(self, cursor, key);\n            self.nodes[cursor].left = self.nodes[key].left;\n            self.nodes[self.nodes[cursor].left].parent = cursor;\n            self.nodes[cursor].right = self.nodes[key].right;\n            self.nodes[self.nodes[cursor].right].parent = cursor;\n            self.nodes[cursor].red = self.nodes[key].red;\n            (cursor, key) = (key, cursor);\n            aggregateRecursively(self, key, aggregate, data);\n        }\n        if (doFixup) {\n            removeFixup(self, probe, aggregate, data);\n        }\n        aggregateRecursively(self, yParent, aggregate, data);\n\n        // Fixed a bug that caused the parent of empty nodes to be non-zero.\n        // TODO: Fix it the right way.\n        if (probe == EMPTY) {\n            self.nodes[probe].parent = EMPTY;\n        }\n    }\n\n    // https://arxiv.org/pdf/1602.02120.pdf\n    // changes from original\n    // - handle empty\n    // - handle parent\n    // - change root to black\n\n    // to avoid stack too deep\n    struct JoinParams {\n        uint40 left;\n        uint40 key;\n        uint40 right;\n        uint8 leftBlackHeight;\n        uint8 rightBlackHeight;\n        uint256 data;\n    }\n\n    // destructive func\n    function joinRight(\n        Tree storage self,\n        JoinParams memory params,\n        function(uint40, uint256) returns (bool) aggregate\n    ) private returns (uint40, uint8) {\n        if (\n            !self.nodes[params.left].red &&\n            params.leftBlackHeight == params.rightBlackHeight\n        ) {\n            self.nodes[params.key].red = true;\n            self.nodes[params.key].left = params.left;\n            self.nodes[params.key].right = params.right;\n            aggregate(params.key, params.data);\n            return (params.key, params.leftBlackHeight);\n        }\n\n        (uint40 t, ) = joinRight(\n            self,\n            JoinParams({\n                left: self.nodes[params.left].right,\n                key: params.key,\n                right: params.right,\n                leftBlackHeight: params.leftBlackHeight -\n                    (self.nodes[params.left].red ? 0 : 1),\n                rightBlackHeight: params.rightBlackHeight,\n                data: params.data\n            }),\n            aggregate\n        );\n        self.nodes[params.left].right = t;\n        self.nodes[params.left].parent = EMPTY;\n        aggregate(params.left, params.data);\n\n        if (\n            !self.nodes[params.left].red &&\n            self.nodes[t].red &&\n            self.nodes[self.nodes[t].right].red\n        ) {\n            self.nodes[self.nodes[t].right].red = false;\n            rotateLeft(self, params.left, aggregate, params.data);\n            return (t, params.leftBlackHeight);\n            //            return (self.nodes[params.left].parent, tBlackHeight + 1); // TODO: replace with t\n        }\n        return (params.left, params.leftBlackHeight);\n        //        return (params.left, tBlackHeight + (self.nodes[params.left].red ? 0 : 1));\n    }\n\n    // destructive func\n    function joinLeft(\n        Tree storage self,\n        JoinParams memory params,\n        function(uint40, uint256) returns (bool) aggregate\n    ) internal returns (uint40 resultKey) {\n        if (\n            !self.nodes[params.right].red &&\n            params.leftBlackHeight == params.rightBlackHeight\n        ) {\n            self.nodes[params.key].red = true;\n            self.nodes[params.key].left = params.left;\n            self.nodes[params.key].right = params.right;\n            if (params.left != EMPTY) {\n                self.nodes[params.left].parent = params.key;\n            }\n            if (params.right != EMPTY) {\n                self.nodes[params.right].parent = params.key;\n            }\n            aggregate(params.key, params.data);\n            return params.key;\n        }\n\n        uint40 t = joinLeft(\n            self,\n            JoinParams({\n                left: params.left,\n                key: params.key,\n                right: self.nodes[params.right].left,\n                leftBlackHeight: params.leftBlackHeight,\n                rightBlackHeight: params.rightBlackHeight -\n                    (self.nodes[params.right].red ? 0 : 1),\n                data: params.data\n            }),\n            aggregate\n        );\n        self.nodes[params.right].left = t;\n        self.nodes[params.right].parent = EMPTY;\n        if (t != EMPTY) {\n            self.nodes[t].parent = params.right;\n        }\n        aggregate(params.right, params.data);\n\n        if (\n            !self.nodes[params.right].red &&\n            self.nodes[t].red &&\n            self.nodes[self.nodes[t].left].red\n        ) {\n            self.nodes[self.nodes[t].left].red = false;\n            rotateRight(self, params.right, aggregate, params.data);\n            return t;\n        }\n        return params.right;\n    }\n\n    // destructive func\n    function join(\n        Tree storage self,\n        uint40 left,\n        uint40 key,\n        uint40 right,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint8 leftBlackHeight,\n        uint8 rightBlackHeight,\n        uint256 data\n    ) private returns (uint40 t, uint8 tBlackHeight) {\n        if (leftBlackHeight > rightBlackHeight) {\n            (t, tBlackHeight) = joinRight(\n                self,\n                JoinParams({\n                    left: left,\n                    key: key,\n                    right: right,\n                    leftBlackHeight: leftBlackHeight,\n                    rightBlackHeight: rightBlackHeight,\n                    data: data\n                }),\n                aggregate\n            );\n            tBlackHeight = leftBlackHeight;\n            if (self.nodes[t].red && self.nodes[self.nodes[t].right].red) {\n                self.nodes[t].red = false;\n                tBlackHeight += 1;\n            }\n        } else if (leftBlackHeight < rightBlackHeight) {\n            t = joinLeft(\n                self,\n                JoinParams({\n                    left: left,\n                    key: key,\n                    right: right,\n                    leftBlackHeight: leftBlackHeight,\n                    rightBlackHeight: rightBlackHeight,\n                    data: data\n                }),\n                aggregate\n            );\n            tBlackHeight = rightBlackHeight;\n            if (self.nodes[t].red && self.nodes[self.nodes[t].left].red) {\n                self.nodes[t].red = false;\n                tBlackHeight += 1;\n            }\n        } else {\n            bool red = !self.nodes[left].red && !self.nodes[right].red;\n            self.nodes[key].red = red;\n            self.nodes[key].left = left;\n            self.nodes[key].right = right;\n            aggregate(key, data);\n            (t, tBlackHeight) = (key, leftBlackHeight + (red ? 0 : 1));\n        }\n    }\n\n    struct SplitParams {\n        uint40 t;\n        uint40 key;\n        uint8 blackHeight;\n        uint256 data;\n    }\n\n    // destructive func\n    function splitRight(\n        Tree storage self,\n        SplitParams memory params,\n        function(uint40, uint40, uint256) returns (bool) lessThan,\n        function(uint40, uint256) returns (bool) aggregate,\n        function(uint40, uint256) subtreeRemoved\n    ) private returns (uint40 resultKey, uint8 resultBlackHeight) {\n        if (params.t == EMPTY) return (EMPTY, params.blackHeight);\n        params.blackHeight -= (self.nodes[params.t].red ? 0 : 1);\n        if (params.key == params.t) {\n            subtreeRemoved(params.t, params.data);\n            return (self.nodes[params.t].right, params.blackHeight);\n        }\n        if (lessThan(params.key, params.t, params.data)) {\n            (uint40 r, uint8 rBlackHeight) = splitRight(\n                self,\n                SplitParams({\n                    t: self.nodes[params.t].left,\n                    key: params.key,\n                    blackHeight: params.blackHeight,\n                    data: params.data\n                }),\n                lessThan,\n                aggregate,\n                subtreeRemoved\n            );\n            return\n                join(\n                    self,\n                    r,\n                    params.t,\n                    self.nodes[params.t].right,\n                    aggregate,\n                    rBlackHeight,\n                    params.blackHeight,\n                    params.data\n                );\n        } else {\n            subtreeRemoved(params.t, params.data);\n            return\n                splitRight(\n                    self,\n                    SplitParams({\n                        t: self.nodes[params.t].right,\n                        key: params.key,\n                        blackHeight: params.blackHeight,\n                        data: params.data\n                    }),\n                    lessThan,\n                    aggregate,\n                    subtreeRemoved\n                );\n        }\n    }\n\n    function removeLeft(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint40, uint256) returns (bool) lessThan,\n        function(uint40, uint256) returns (bool) aggregate,\n        function(uint40, uint256) subtreeRemoved,\n        uint256 data\n    ) internal {\n        require(key != EMPTY, \"RBTL_RL: key is empty\");\n        require(exists(self, key), \"RBTL_RL: key not exist\");\n        (self.root, ) = splitRight(\n            self,\n            SplitParams({t: self.root, key: key, blackHeight: 128, data: data}),\n            lessThan,\n            aggregate,\n            subtreeRemoved\n        );\n        self.nodes[self.root].parent = EMPTY;\n        self.nodes[self.root].red = false;\n    }\n\n    function aggregateRecursively(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) internal {\n        while (key != EMPTY) {\n            if (aggregate(key, data)) return;\n            key = self.nodes[key].parent;\n        }\n    }\n\n    function treeMinimum(Tree storage self, uint40 key)\n        private\n        view\n        returns (uint40)\n    {\n        while (self.nodes[key].left != EMPTY) {\n            key = self.nodes[key].left;\n        }\n        return key;\n    }\n\n    function treeMaximum(Tree storage self, uint40 key)\n        private\n        view\n        returns (uint40)\n    {\n        while (self.nodes[key].right != EMPTY) {\n            key = self.nodes[key].right;\n        }\n        return key;\n    }\n\n    function rotateLeft(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) private {\n        uint40 cursor = self.nodes[key].right;\n        uint40 keyParent = self.nodes[key].parent;\n        uint40 cursorLeft = self.nodes[cursor].left;\n        self.nodes[key].right = cursorLeft;\n        if (cursorLeft != EMPTY) {\n            self.nodes[cursorLeft].parent = key;\n        }\n        self.nodes[cursor].parent = keyParent;\n        if (keyParent == EMPTY) {\n            self.root = cursor;\n        } else if (key == self.nodes[keyParent].left) {\n            self.nodes[keyParent].left = cursor;\n        } else {\n            self.nodes[keyParent].right = cursor;\n        }\n        self.nodes[cursor].left = key;\n        self.nodes[key].parent = cursor;\n        aggregate(key, data);\n        aggregate(cursor, data);\n    }\n\n    function rotateRight(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) private {\n        uint40 cursor = self.nodes[key].left;\n        uint40 keyParent = self.nodes[key].parent;\n        uint40 cursorRight = self.nodes[cursor].right;\n        self.nodes[key].left = cursorRight;\n        if (cursorRight != EMPTY) {\n            self.nodes[cursorRight].parent = key;\n        }\n        self.nodes[cursor].parent = keyParent;\n        if (keyParent == EMPTY) {\n            self.root = cursor;\n        } else if (key == self.nodes[keyParent].right) {\n            self.nodes[keyParent].right = cursor;\n        } else {\n            self.nodes[keyParent].left = cursor;\n        }\n        self.nodes[cursor].right = key;\n        self.nodes[key].parent = cursor;\n        aggregate(key, data);\n        aggregate(cursor, data);\n    }\n\n    function insertFixup(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) private {\n        uint40 cursor;\n        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n            uint40 keyParent = self.nodes[key].parent;\n            if (keyParent == self.nodes[self.nodes[keyParent].parent].left) {\n                cursor = self.nodes[self.nodes[keyParent].parent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[keyParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[keyParent].parent].red = true;\n                    key = self.nodes[keyParent].parent;\n                } else {\n                    if (key == self.nodes[keyParent].right) {\n                        key = keyParent;\n                        rotateLeft(self, key, aggregate, data);\n                    }\n                    keyParent = self.nodes[key].parent;\n                    self.nodes[keyParent].red = false;\n                    self.nodes[self.nodes[keyParent].parent].red = true;\n                    rotateRight(\n                        self,\n                        self.nodes[keyParent].parent,\n                        aggregate,\n                        data\n                    );\n                }\n            } else {\n                cursor = self.nodes[self.nodes[keyParent].parent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[keyParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[keyParent].parent].red = true;\n                    key = self.nodes[keyParent].parent;\n                } else {\n                    if (key == self.nodes[keyParent].left) {\n                        key = keyParent;\n                        rotateRight(self, key, aggregate, data);\n                    }\n                    keyParent = self.nodes[key].parent;\n                    self.nodes[keyParent].red = false;\n                    self.nodes[self.nodes[keyParent].parent].red = true;\n                    rotateLeft(\n                        self,\n                        self.nodes[keyParent].parent,\n                        aggregate,\n                        data\n                    );\n                }\n            }\n        }\n        self.nodes[self.root].red = false;\n    }\n\n    function replaceParent(\n        Tree storage self,\n        uint40 a,\n        uint40 b\n    ) private {\n        uint40 bParent = self.nodes[b].parent;\n        self.nodes[a].parent = bParent;\n        if (bParent == EMPTY) {\n            self.root = a;\n        } else {\n            if (b == self.nodes[bParent].left) {\n                self.nodes[bParent].left = a;\n            } else {\n                self.nodes[bParent].right = a;\n            }\n        }\n    }\n\n    function removeFixup(\n        Tree storage self,\n        uint40 key,\n        function(uint40, uint256) returns (bool) aggregate,\n        uint256 data\n    ) private {\n        uint40 cursor;\n        while (key != self.root && !self.nodes[key].red) {\n            uint40 keyParent = self.nodes[key].parent;\n            if (key == self.nodes[keyParent].left) {\n                cursor = self.nodes[keyParent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[keyParent].red = true;\n                    rotateLeft(self, keyParent, aggregate, data);\n                    cursor = self.nodes[keyParent].right;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].left].red &&\n                    !self.nodes[self.nodes[cursor].right].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    key = keyParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].right].red) {\n                        self.nodes[self.nodes[cursor].left].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateRight(self, cursor, aggregate, data);\n                        cursor = self.nodes[keyParent].right;\n                    }\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\n                    self.nodes[keyParent].red = false;\n                    self.nodes[self.nodes[cursor].right].red = false;\n                    rotateLeft(self, keyParent, aggregate, data);\n                    key = self.root;\n                }\n            } else {\n                cursor = self.nodes[keyParent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[keyParent].red = true;\n                    rotateRight(self, keyParent, aggregate, data);\n                    cursor = self.nodes[keyParent].left;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].right].red &&\n                    !self.nodes[self.nodes[cursor].left].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    key = keyParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].left].red) {\n                        self.nodes[self.nodes[cursor].right].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateLeft(self, cursor, aggregate, data);\n                        cursor = self.nodes[keyParent].left;\n                    }\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\n                    self.nodes[keyParent].red = false;\n                    self.nodes[self.nodes[cursor].left].red = false;\n                    rotateRight(self, keyParent, aggregate, data);\n                    key = self.root;\n                }\n            }\n        }\n        self.nodes[key].red = false;\n    }\n}\n// ----------------------------------------------------------------------------\n// End - BokkyPooBah's Red-Black Tree Library\n// ----------------------------------------------------------------------------\n"
    },
    "deps/perpdex-contract/contracts/interfaces/IPerpdexMarketMinimum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IPerpdexMarketMinimum {\n    struct SwapResponse {\n        uint256 oppositeAmount;\n        uint256 basePartial;\n        uint256 quotePartial;\n        uint40 partialOrderId;\n    }\n\n    function swap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bool isLiquidation\n    ) external returns (SwapResponse memory response);\n\n    function addLiquidity(uint256 baseShare, uint256 quoteBalance)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function removeLiquidity(uint256 liquidity) external returns (uint256 baseShare, uint256 quoteBalance);\n\n    function createLimitOrder(\n        bool isBid,\n        uint256 baseShare,\n        uint256 priceX96\n    ) external returns (uint40 orderId);\n\n    function cancelLimitOrder(bool isBid, uint40 orderId) external;\n\n    // getters\n\n    function previewSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bool isLiquidation\n    ) external view returns (uint256);\n\n    function maxSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        bool isLiquidation\n    ) external view returns (uint256 amount);\n\n    function exchange() external view returns (address);\n\n    function getShareMarkPriceX96() external view returns (uint256);\n\n    function getLiquidityValue(uint256 liquidity) external view returns (uint256 baseShare, uint256 quoteBalance);\n\n    function getLiquidityDeleveraged(\n        uint256 liquidity,\n        uint256 cumBasePerLiquidityX96,\n        uint256 cumQuotePerLiquidityX96\n    ) external view returns (int256, int256);\n\n    function getCumDeleveragedPerLiquidityX96() external view returns (uint256, uint256);\n\n    function baseBalancePerShareX96() external view returns (uint256);\n\n    function getLimitOrderInfo(bool isBid, uint40 orderId) external view returns (uint256 base, uint256 priceX96);\n\n    function getLimitOrderExecution(bool isBid, uint40 orderId)\n        external\n        view\n        returns (\n            uint256 executionId,\n            uint256 executedBase,\n            uint256 executedQuote\n        );\n}\n"
    },
    "contracts/test/TestPerpdexTokenBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { PerpdexTokenBase } from \"../PerpdexTokenBase.sol\";\n\n// for testing internal method\ncontract TestPerpdexTokenBase is PerpdexTokenBase {\n    constructor(\n        address marketArg,\n        string memory namePrefix,\n        string memory symbolPrefix,\n        address wethArg\n    ) PerpdexTokenBase(marketArg, namePrefix, symbolPrefix, \"ETH\", wethArg) {}\n\n    function previewDeposit(uint256 assets) external view override returns (uint256 shares) {}\n\n    function previewMint(uint256 shares) external view override returns (uint256 assets) {}\n\n    function previewWithdraw(uint256 assets) external view override returns (uint256 shares) {}\n\n    function previewRedeem(uint256 shares) external view override returns (uint256 assets) {}\n\n    function maxDeposit(address receiver) external view override returns (uint256 maxAssets) {}\n\n    function maxMint(address receiver) external view override returns (uint256 maxShares) {}\n\n    function maxWithdraw(address owner) external view override returns (uint256 maxAssets) {}\n\n    function maxRedeem(address owner) external view override returns (uint256 maxShares) {}\n\n    function mint(uint256 shares, address receiver) external override returns (uint256 assets) {}\n\n    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {}\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override returns (uint256 assets) {}\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override returns (uint256 shares) {}\n\n    // for unit test\n    function spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external {\n        _spendAllowance(owner, spender, amount);\n    }\n\n    function testMint(address receiver, uint256 shares) external {\n        _mint(receiver, shares);\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.7.6;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/VaultLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { IERC20Metadata } from \"../interfaces/IERC20Metadata.sol\";\nimport { AccountLibrary } from \"./AccountLibrary.sol\";\nimport { PerpdexStructs } from \"./PerpdexStructs.sol\";\n\nlibrary VaultLibrary {\n    using PerpMath for int256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct DepositParams {\n        address settlementToken;\n        uint256 amount;\n        address from;\n    }\n\n    struct WithdrawParams {\n        address settlementToken;\n        uint256 amount;\n        address payable to;\n        uint24 imRatio;\n    }\n\n    function compensate(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        PerpdexStructs.InsuranceFundInfo storage insuranceFundInfo\n    ) external returns (uint256 compensation) {\n        if (accountInfo.markets.length != 0) return 0;\n        if (accountInfo.vaultInfo.collateralBalance >= 0) return 0;\n        compensation = Math.min((-accountInfo.vaultInfo.collateralBalance).toUint256(), insuranceFundInfo.balance);\n        accountInfo.vaultInfo.collateralBalance += compensation.toInt256();\n        insuranceFundInfo.balance -= compensation;\n    }\n\n    function deposit(PerpdexStructs.AccountInfo storage accountInfo, DepositParams memory params) external {\n        require(params.amount > 0, \"VL_D: zero amount\");\n        _transferTokenIn(params.settlementToken, params.from, params.amount);\n        uint256 collateralAmount =\n            _toCollateralAmount(params.amount, IERC20Metadata(params.settlementToken).decimals());\n        accountInfo.vaultInfo.collateralBalance = accountInfo.vaultInfo.collateralBalance.add(\n            collateralAmount.toInt256()\n        );\n    }\n\n    function depositEth(PerpdexStructs.AccountInfo storage accountInfo, uint256 amount) external {\n        require(amount > 0, \"VL_DE: zero amount\");\n        accountInfo.vaultInfo.collateralBalance = accountInfo.vaultInfo.collateralBalance.add(amount.toInt256());\n    }\n\n    function withdraw(PerpdexStructs.AccountInfo storage accountInfo, WithdrawParams memory params) external {\n        require(params.amount > 0, \"VL_W: zero amount\");\n\n        uint256 collateralAmount =\n            params.settlementToken == address(0)\n                ? params.amount\n                : _toCollateralAmount(params.amount, IERC20Metadata(params.settlementToken).decimals());\n        accountInfo.vaultInfo.collateralBalance = accountInfo.vaultInfo.collateralBalance.sub(\n            collateralAmount.toInt256()\n        );\n\n        require(AccountLibrary.hasEnoughInitialMargin(accountInfo, params.imRatio), \"VL_W: not enough initial margin\");\n\n        if (params.settlementToken == address(0)) {\n            params.to.transfer(params.amount);\n        } else {\n            SafeERC20.safeTransfer(IERC20(params.settlementToken), params.to, params.amount);\n        }\n    }\n\n    function transferProtocolFee(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        PerpdexStructs.ProtocolInfo storage protocolInfo,\n        uint256 amount\n    ) external {\n        accountInfo.vaultInfo.collateralBalance = accountInfo.vaultInfo.collateralBalance.add(amount.toInt256());\n        protocolInfo.protocolFee = protocolInfo.protocolFee.sub(amount);\n    }\n\n    function _transferTokenIn(\n        address token,\n        address from,\n        uint256 amount\n    ) private {\n        // check for deflationary tokens by assuring balances before and after transferring to be the same\n        uint256 balanceBefore = IERC20Metadata(token).balanceOf(address(this));\n        SafeERC20.safeTransferFrom(IERC20(token), from, address(this), amount);\n        require(\n            (IERC20Metadata(token).balanceOf(address(this)).sub(balanceBefore)) == amount,\n            \"VL_TTI: inconsistent balance\"\n        );\n    }\n\n    function _toCollateralAmount(uint256 amount, uint8 tokenDecimals) private pure returns (uint256) {\n        int256 decimalsDiff = int256(18).sub(uint256(tokenDecimals).toInt256());\n        uint256 decimalsDiffAbs = decimalsDiff.abs();\n        require(decimalsDiffAbs <= 77, \"VL_TCA: too large decimals diff\");\n        return decimalsDiff >= 0 ? amount.mul(10**decimalsDiffAbs) : amount.div(10**decimalsDiffAbs);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/PerpMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nlibrary PerpMath {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    function formatSqrtPriceX96ToPriceX96(uint160 sqrtPriceX96) internal pure returns (uint256) {\n        return Math.mulDiv(sqrtPriceX96, sqrtPriceX96, FixedPoint96.Q96);\n    }\n\n    function formatX10_18ToX96(uint256 valueX10_18) internal pure returns (uint256) {\n        return Math.mulDiv(valueX10_18, FixedPoint96.Q96, 1 ether);\n    }\n\n    function formatX96ToX10_18(uint256 valueX96) internal pure returns (uint256) {\n        return Math.mulDiv(valueX96, 1 ether, FixedPoint96.Q96);\n    }\n\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    function abs(int256 value) internal pure returns (uint256) {\n        return value >= 0 ? value.toUint256() : neg256(value).toUint256();\n    }\n\n    function neg256(int256 a) internal pure returns (int256) {\n        require(a > -2**255, \"PerpMath: inversion overflow\");\n        return -a;\n    }\n\n    function neg256(uint256 a) internal pure returns (int256) {\n        return -SafeCast.toInt256(a);\n    }\n\n    function divBy10_18(int256 value) internal pure returns (int256) {\n        // no overflow here\n        return value / (1 ether);\n    }\n\n    function divBy10_18(uint256 value) internal pure returns (uint256) {\n        // no overflow here\n        return value / (1 ether);\n    }\n\n    function subRatio(uint24 a, uint24 b) internal pure returns (uint24) {\n        require(b <= a, \"PerpMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mulRatio(uint256 value, uint24 ratio) internal pure returns (uint256) {\n        return Math.mulDiv(value, ratio, 1e6);\n    }\n\n    function mulRatioRoundingUp(uint256 value, uint24 ratio) internal pure returns (uint256) {\n        return Math.mulDiv(value, ratio, 1e6, Math.Rounding.Up);\n    }\n\n    function divRatio(uint256 value, uint24 ratio) internal pure returns (uint256) {\n        return Math.mulDiv(value, 1e6, ratio);\n    }\n\n    function divRatioRoundingUp(uint256 value, uint24 ratio) internal pure returns (uint256) {\n        return Math.mulDiv(value, 1e6, ratio, Math.Rounding.Up);\n    }\n\n    /// @param denominator cannot be 0 and is checked in Math.mulDiv()\n    function mulDiv(\n        int256 a,\n        int256 b,\n        uint256 denominator\n    ) internal pure returns (int256 result) {\n        uint256 unsignedA = a < 0 ? uint256(neg256(a)) : uint256(a);\n        uint256 unsignedB = b < 0 ? uint256(neg256(b)) : uint256(b);\n        bool negative = ((a < 0 && b > 0) || (a > 0 && b < 0)) ? true : false;\n\n        uint256 unsignedResult = Math.mulDiv(unsignedA, unsignedB, denominator);\n\n        result = negative ? neg256(unsignedResult) : SafeCast.toInt256(unsignedResult);\n\n        return result;\n    }\n\n    function sign(int256 value) internal pure returns (int256) {\n        return value > 0 ? int256(1) : (value < 0 ? int256(-1) : int256(0));\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/AccountLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\n\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IPerpdexMarketMinimum } from \"../interfaces/IPerpdexMarketMinimum.sol\";\nimport { PerpdexStructs } from \"./PerpdexStructs.sol\";\nimport { AccountPreviewLibrary } from \"./AccountPreviewLibrary.sol\";\n\n// https://help.ftx.com/hc/en-us/articles/360024780511-Complete-Futures-Specs\nlibrary AccountLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct CalcMarketResponse {\n        int256 baseShare;\n        uint256 baseSharePool;\n        uint256 baseShareAsk;\n        uint256 baseShareBid;\n        int256 quoteBalance;\n        uint256 quoteBalancePool;\n        int256 positionNotional;\n        uint256 openPositionShare;\n        uint256 openPositionNotional;\n        int256 positionValue;\n        int256 realizedPnl;\n    }\n\n    struct CalcTotalResponse {\n        int256 accountValue;\n        int256 collateralBalance;\n        uint256 totalPositionNotional;\n        uint256 totalOpenPositionNotional;\n        bool isLiquidationFree;\n    }\n\n    function updateMarkets(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        uint8 maxMarketsPerAccount\n    ) external {\n        bool enabled =\n            accountInfo.takerInfos[market].baseBalanceShare != 0 ||\n                accountInfo.makerInfos[market].liquidity != 0 ||\n                accountInfo.limitOrderInfos[market].ask.root != 0 ||\n                accountInfo.limitOrderInfos[market].bid.root != 0;\n        address[] storage markets = accountInfo.markets;\n        uint256 length = markets.length;\n\n        for (uint256 i = 0; i < length; ++i) {\n            if (markets[i] == market) {\n                if (!enabled) {\n                    markets[i] = markets[length - 1];\n                    markets.pop();\n                }\n                return;\n            }\n        }\n\n        if (!enabled) return;\n\n        require(length + 1 <= maxMarketsPerAccount, \"AL_UP: too many markets\");\n        markets.push(market);\n    }\n\n    function getTakerInfo(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        external\n        view\n        returns (PerpdexStructs.TakerInfo memory takerInfo)\n    {\n        (AccountPreviewLibrary.Execution[] memory executions, , ) =\n            AccountPreviewLibrary.getLimitOrderExecutions(accountInfo, market);\n        (takerInfo, , , ) = AccountPreviewLibrary.previewSettleLimitOrders(accountInfo, market, executions);\n    }\n\n    function getCollateralBalance(PerpdexStructs.AccountInfo storage accountInfo) external view returns (int256) {\n        return _calcTotal(accountInfo).collateralBalance;\n    }\n\n    function getTotalAccountValue(PerpdexStructs.AccountInfo storage accountInfo) external view returns (int256) {\n        return _calcTotal(accountInfo).accountValue;\n    }\n\n    function getPositionShare(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        external\n        view\n        returns (int256)\n    {\n        return _calcMarket(accountInfo, market).baseShare;\n    }\n\n    function getPositionNotional(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        external\n        view\n        returns (int256)\n    {\n        return _calcMarket(accountInfo, market).positionNotional;\n    }\n\n    function getTotalPositionNotional(PerpdexStructs.AccountInfo storage accountInfo) external view returns (uint256) {\n        return _calcTotal(accountInfo).totalPositionNotional;\n    }\n\n    function getOpenPositionShare(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        external\n        view\n        returns (uint256)\n    {\n        return _calcMarket(accountInfo, market).openPositionShare;\n    }\n\n    function getOpenPositionNotional(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        external\n        view\n        returns (uint256)\n    {\n        return _calcMarket(accountInfo, market).openPositionNotional;\n    }\n\n    function getTotalOpenPositionNotional(PerpdexStructs.AccountInfo storage accountInfo)\n        external\n        view\n        returns (uint256)\n    {\n        return _calcTotal(accountInfo).totalOpenPositionNotional;\n    }\n\n    function hasEnoughMaintenanceMargin(PerpdexStructs.AccountInfo storage accountInfo, uint24 mmRatio)\n        external\n        view\n        returns (bool)\n    {\n        CalcTotalResponse memory response = _calcTotal(accountInfo);\n        return response.accountValue.mul(1e6) >= response.totalPositionNotional.mul(mmRatio).toInt256();\n    }\n\n    // always true when hasEnoughMaintenanceMargin is true\n    function hasEnoughInitialMargin(PerpdexStructs.AccountInfo storage accountInfo, uint24 imRatio)\n        external\n        view\n        returns (bool)\n    {\n        CalcTotalResponse memory response = _calcTotal(accountInfo);\n        return\n            response.accountValue.min(response.collateralBalance).mul(1e6) >=\n            response.totalOpenPositionNotional.mul(imRatio).toInt256() ||\n            response.isLiquidationFree;\n    }\n\n    function isLiquidationFree(PerpdexStructs.AccountInfo storage accountInfo) external view returns (bool) {\n        return _calcTotal(accountInfo).isLiquidationFree;\n    }\n\n    function _calcMarket(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        private\n        view\n        returns (CalcMarketResponse memory response)\n    {\n        PerpdexStructs.MakerInfo storage makerInfo = accountInfo.makerInfos[market];\n        PerpdexStructs.TakerInfo memory takerInfo;\n        (AccountPreviewLibrary.Execution[] memory executions, , ) =\n            AccountPreviewLibrary.getLimitOrderExecutions(accountInfo, market);\n\n        uint256 totalExecutedBaseAsk;\n        uint256 totalExecutedBaseBid;\n        (takerInfo, response.realizedPnl, totalExecutedBaseAsk, totalExecutedBaseBid) = AccountPreviewLibrary\n            .previewSettleLimitOrders(accountInfo, market, executions);\n\n        response.baseShare = takerInfo.baseBalanceShare;\n        response.quoteBalance = takerInfo.quoteBalance;\n\n        uint256 totalOrderBaseAsk;\n        uint256 totalOrderBaseBid;\n        if (makerInfo.liquidity != 0) {\n            (uint256 poolBaseShare, uint256 poolQuoteBalance) =\n                IPerpdexMarketMinimum(market).getLiquidityValue(makerInfo.liquidity);\n            (int256 deleveragedBaseShare, int256 deleveragedQuoteBalance) =\n                IPerpdexMarketMinimum(market).getLiquidityDeleveraged(\n                    makerInfo.liquidity,\n                    makerInfo.cumBaseSharePerLiquidityX96,\n                    makerInfo.cumQuotePerLiquidityX96\n                );\n            response.baseSharePool = poolBaseShare;\n            response.baseShare = response.baseShare.add(deleveragedBaseShare).add(response.baseSharePool.toInt256());\n            response.quoteBalancePool = poolQuoteBalance;\n            response.quoteBalance = response.quoteBalance.add(deleveragedQuoteBalance).add(\n                response.quoteBalancePool.toInt256()\n            );\n            totalOrderBaseAsk = poolBaseShare;\n            totalOrderBaseBid = poolBaseShare;\n        }\n\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[market];\n        response.baseShareAsk = limitOrderInfo.totalBaseAsk - totalExecutedBaseAsk;\n        response.baseShareBid = limitOrderInfo.totalBaseBid - totalExecutedBaseBid;\n        totalOrderBaseAsk += response.baseShareAsk;\n        totalOrderBaseBid += response.baseShareBid;\n        response.openPositionShare = Math.max(\n            (response.baseShare - totalOrderBaseAsk.toInt256()).abs(),\n            (response.baseShare + totalOrderBaseBid.toInt256()).abs()\n        );\n\n        if (response.openPositionShare != 0) {\n            uint256 sharePriceX96 = IPerpdexMarketMinimum(market).getShareMarkPriceX96();\n            response.openPositionNotional = Math.mulDiv(response.openPositionShare, sharePriceX96, FixedPoint96.Q96);\n\n            if (response.baseShare != 0) {\n                response.positionNotional = response.baseShare.mulDiv(sharePriceX96.toInt256(), FixedPoint96.Q96);\n                response.positionValue = response.positionValue.add(response.positionNotional);\n            }\n        }\n\n        response.positionValue = response.positionValue.add(response.quoteBalance);\n    }\n\n    function _calcTotal(PerpdexStructs.AccountInfo storage accountInfo)\n        private\n        view\n        returns (CalcTotalResponse memory response)\n    {\n        response.collateralBalance = accountInfo.vaultInfo.collateralBalance;\n        response.isLiquidationFree = true;\n        int256 quoteBalanceWithoutPool;\n\n        address[] storage markets = accountInfo.markets;\n        uint256 length = markets.length;\n        for (uint256 i = 0; i < length; ++i) {\n            address market = markets[i];\n\n            CalcMarketResponse memory marketResponse = _calcMarket(accountInfo, market);\n\n            response.accountValue = response.accountValue.add(marketResponse.positionValue);\n            response.collateralBalance = response.collateralBalance.add(marketResponse.realizedPnl);\n            response.totalPositionNotional = response.totalPositionNotional.add(marketResponse.positionNotional.abs());\n            response.totalOpenPositionNotional = response.totalOpenPositionNotional.add(\n                marketResponse.openPositionNotional\n            );\n\n            response.isLiquidationFree =\n                response.isLiquidationFree &&\n                marketResponse.baseShare >= marketResponse.baseShareAsk.add(marketResponse.baseSharePool).toInt256() &&\n                marketResponse.baseShareBid == 0;\n            quoteBalanceWithoutPool = quoteBalanceWithoutPool.add(\n                marketResponse.quoteBalance - marketResponse.quoteBalancePool.toInt256()\n            );\n        }\n        response.accountValue = response.accountValue.add(response.collateralBalance);\n        response.isLiquidationFree =\n            response.isLiquidationFree &&\n            quoteBalanceWithoutPool.add(response.collateralBalance) >= 0;\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/AccountPreviewLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { IPerpdexMarketMinimum } from \"../interfaces/IPerpdexMarketMinimum.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { PerpdexStructs } from \"./PerpdexStructs.sol\";\nimport {\n    BokkyPooBahsRedBlackTreeLibrary as RBTreeLibrary\n} from \"../../deps/BokkyPooBahsRedBlackTreeLibrary/contracts/BokkyPooBahsRedBlackTreeLibrary.sol\";\n\n// This is a technical library to avoid circular references between libraries\nlibrary AccountPreviewLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using RBTreeLibrary for RBTreeLibrary.Tree;\n\n    struct Execution {\n        int256 executedBase;\n        int256 executedQuote;\n    }\n\n    function getLimitOrderExecutions(PerpdexStructs.AccountInfo storage accountInfo, address market)\n        internal\n        view\n        returns (\n            Execution[] memory executions,\n            uint40 executedLastAskOrderId,\n            uint40 executedLastBidOrderId\n        )\n    {\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[market];\n\n        uint40 ask = limitOrderInfo.ask.first();\n        uint40 bid = limitOrderInfo.bid.first();\n        uint256 executionIdAsk;\n        uint256 executedBaseAsk;\n        uint256 executedQuoteAsk;\n        uint256 executionIdBid;\n        uint256 executedBaseBid;\n        uint256 executedQuoteBid;\n        if (ask != 0) {\n            (executionIdAsk, executedBaseAsk, executedQuoteAsk) = IPerpdexMarketMinimum(market).getLimitOrderExecution(\n                false,\n                ask\n            );\n            if (executionIdAsk == 0) {\n                ask = 0;\n            }\n        }\n        if (bid != 0) {\n            (executionIdBid, executedBaseBid, executedQuoteBid) = IPerpdexMarketMinimum(market).getLimitOrderExecution(\n                true,\n                bid\n            );\n            if (executionIdBid == 0) {\n                bid = 0;\n            }\n        }\n\n        // Combine the ask and bid and process from the one with the smallest executionId.\n        // Ask and bid are already sorted and can be processed like merge sort.\n        Execution[256] memory executions2;\n        uint256 executionCount;\n        while (ask != 0 || bid != 0) {\n            if (ask != 0 && (bid == 0 || executionIdAsk < executionIdBid)) {\n                executions2[executionCount] = Execution({\n                    executedBase: executedBaseAsk.neg256(),\n                    executedQuote: executedQuoteAsk.toInt256()\n                });\n                ++executionCount;\n\n                uint40 nextAsk = limitOrderInfo.ask.next(ask);\n                if (nextAsk != 0) {\n                    (executionIdAsk, executedBaseAsk, executedQuoteAsk) = IPerpdexMarketMinimum(market)\n                        .getLimitOrderExecution(false, nextAsk);\n                }\n                if (executionIdAsk == 0 || nextAsk == 0) {\n                    executedLastAskOrderId = ask;\n                    ask = 0;\n                } else {\n                    ask = nextAsk;\n                }\n            } else {\n                executions2[executionCount] = Execution({\n                    executedBase: executedBaseBid.toInt256(),\n                    executedQuote: executedQuoteBid.neg256()\n                });\n                ++executionCount;\n\n                uint40 nextBid = limitOrderInfo.bid.next(bid);\n                if (nextBid != 0) {\n                    (executionIdBid, executedBaseBid, executedQuoteBid) = IPerpdexMarketMinimum(market)\n                        .getLimitOrderExecution(true, nextBid);\n                }\n                if (executionIdBid == 0 || nextBid == 0) {\n                    executedLastBidOrderId = bid;\n                    bid = 0;\n                } else {\n                    bid = nextBid;\n                }\n            }\n        }\n\n        executions = new Execution[](executionCount);\n        for (uint256 i = 0; i < executionCount; i++) {\n            executions[i] = executions2[i];\n        }\n    }\n\n    function previewSettleLimitOrders(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        Execution[] memory executions\n    )\n        internal\n        view\n        returns (\n            PerpdexStructs.TakerInfo memory takerInfo,\n            int256 realizedPnl,\n            uint256 totalExecutedBaseAsk,\n            uint256 totalExecutedBaseBid\n        )\n    {\n        takerInfo = accountInfo.takerInfos[market];\n\n        uint256 length = executions.length;\n        for (uint256 i = 0; i < length; ++i) {\n            int256 realizedPnl2;\n            (takerInfo, realizedPnl2) = previewAddToTakerBalance(\n                takerInfo,\n                executions[i].executedBase,\n                executions[i].executedQuote,\n                0\n            );\n            realizedPnl += realizedPnl2;\n            if (executions[i].executedBase >= 0) {\n                totalExecutedBaseBid += executions[i].executedBase.abs();\n            } else {\n                totalExecutedBaseAsk += executions[i].executedBase.abs();\n            }\n        }\n    }\n\n    function previewAddToTakerBalance(\n        PerpdexStructs.TakerInfo memory takerInfo,\n        int256 baseShare,\n        int256 quoteBalance,\n        int256 quoteFee\n    ) internal pure returns (PerpdexStructs.TakerInfo memory resultTakerInfo, int256 realizedPnl) {\n        if (baseShare != 0 || quoteBalance != 0) {\n            if (baseShare.sign() * quoteBalance.sign() != -1) {\n                // ignore invalid input\n                return (takerInfo, 0);\n            }\n            if (takerInfo.baseBalanceShare.sign() * baseShare.sign() == -1) {\n                uint256 baseAbs = baseShare.abs();\n                uint256 takerBaseAbs = takerInfo.baseBalanceShare.abs();\n\n                if (baseAbs <= takerBaseAbs) {\n                    int256 reducedOpenNotional = takerInfo.quoteBalance.mulDiv(baseAbs.toInt256(), takerBaseAbs);\n                    realizedPnl = quoteBalance.add(reducedOpenNotional);\n                } else {\n                    int256 closedPositionNotional = quoteBalance.mulDiv(takerBaseAbs.toInt256(), baseAbs);\n                    realizedPnl = takerInfo.quoteBalance.add(closedPositionNotional);\n                }\n            }\n        }\n        realizedPnl = realizedPnl.add(quoteFee);\n\n        int256 newBaseBalanceShare = takerInfo.baseBalanceShare.add(baseShare);\n        int256 newQuoteBalance = takerInfo.quoteBalance.add(quoteBalance).add(quoteFee).sub(realizedPnl);\n        if (\n            !((newBaseBalanceShare == 0 && newQuoteBalance == 0) ||\n                newBaseBalanceShare.sign() * newQuoteBalance.sign() == -1)\n        ) {\n            // never occur. ignore\n            return (takerInfo, 0);\n        }\n\n        resultTakerInfo.baseBalanceShare = newBaseBalanceShare;\n        resultTakerInfo.quoteBalance = newQuoteBalance;\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/MakerOrderBookLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IPerpdexMarketMinimum } from \"../interfaces/IPerpdexMarketMinimum.sol\";\nimport { PerpdexStructs } from \"./PerpdexStructs.sol\";\nimport { AccountLibrary } from \"./AccountLibrary.sol\";\nimport { AccountPreviewLibrary } from \"./AccountPreviewLibrary.sol\";\nimport { TakerLibrary } from \"./TakerLibrary.sol\";\nimport {\n    BokkyPooBahsRedBlackTreeLibrary as RBTreeLibrary\n} from \"../../deps/BokkyPooBahsRedBlackTreeLibrary/contracts/BokkyPooBahsRedBlackTreeLibrary.sol\";\n\nlibrary MakerOrderBookLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using RBTreeLibrary for RBTreeLibrary.Tree;\n\n    struct CreateLimitOrderParams {\n        address market;\n        uint256 base;\n        uint256 priceX96;\n        bool isBid;\n        uint24 imRatio;\n        uint8 maxMarketsPerAccount;\n        uint8 maxOrdersPerAccount;\n    }\n\n    struct CancelLimitOrderParams {\n        address market;\n        uint40 orderId;\n        bool isBid;\n        uint24 mmRatio;\n        bool isSelf;\n        uint8 maxMarketsPerAccount;\n    }\n\n    function createLimitOrder(PerpdexStructs.AccountInfo storage accountInfo, CreateLimitOrderParams memory params)\n        public\n        returns (uint40 orderId)\n    {\n        require(accountInfo.limitOrderCount < params.maxOrdersPerAccount, \"MOBL_CLO: max order count\");\n        orderId = IPerpdexMarketMinimum(params.market).createLimitOrder(params.isBid, params.base, params.priceX96);\n\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[params.market];\n        uint256 slot = _getSlot(limitOrderInfo);\n        if (params.isBid) {\n            limitOrderInfo.bid.insert(orderId, makeUserData(params.priceX96), _lessThanBid, _aggregate, slot);\n            limitOrderInfo.totalBaseBid += params.base;\n        } else {\n            limitOrderInfo.ask.insert(orderId, makeUserData(params.priceX96), _lessThanAsk, _aggregate, slot);\n            limitOrderInfo.totalBaseAsk += params.base;\n        }\n        accountInfo.limitOrderCount += 1;\n\n        AccountLibrary.updateMarkets(accountInfo, params.market, params.maxMarketsPerAccount);\n\n        require(AccountLibrary.hasEnoughInitialMargin(accountInfo, params.imRatio), \"MOBL_CLO: not enough im\");\n    }\n\n    function cancelLimitOrder(PerpdexStructs.AccountInfo storage accountInfo, CancelLimitOrderParams memory params)\n        public\n        returns (bool isLiquidation)\n    {\n        isLiquidation = !AccountLibrary.hasEnoughMaintenanceMargin(accountInfo, params.mmRatio);\n\n        if (!params.isSelf) {\n            require(isLiquidation, \"MOBL_CLO: enough mm\");\n        }\n\n        (uint256 base, ) = IPerpdexMarketMinimum(params.market).getLimitOrderInfo(params.isBid, params.orderId);\n        IPerpdexMarketMinimum(params.market).cancelLimitOrder(params.isBid, params.orderId);\n\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[params.market];\n        if (params.isBid) {\n            limitOrderInfo.totalBaseBid -= base;\n            limitOrderInfo.bid.remove(params.orderId, _aggregate, 0);\n        } else {\n            limitOrderInfo.totalBaseAsk -= base;\n            limitOrderInfo.ask.remove(params.orderId, _aggregate, 0);\n        }\n        accountInfo.limitOrderCount -= 1;\n\n        AccountLibrary.updateMarkets(accountInfo, params.market, params.maxMarketsPerAccount);\n    }\n\n    function makeUserData(uint256 priceX96) internal pure returns (uint128) {\n        return priceX96.toUint128();\n    }\n\n    function userDataToPriceX96(uint128 userData) internal pure returns (uint128) {\n        return userData;\n    }\n\n    function _lessThan(\n        RBTreeLibrary.Tree storage tree,\n        bool isBid,\n        uint40 key0,\n        uint40 key1\n    ) private view returns (bool) {\n        uint128 price0 = userDataToPriceX96(tree.nodes[key0].userData);\n        uint128 price1 = userDataToPriceX96(tree.nodes[key1].userData);\n        if (price0 == price1) {\n            return key0 < key1; // time priority\n        }\n        // price priority\n        return isBid ? price0 > price1 : price0 < price1;\n    }\n\n    function _lessThanAsk(\n        uint40 key0,\n        uint40 key1,\n        uint256 slot\n    ) private view returns (bool) {\n        PerpdexStructs.LimitOrderInfo storage info = _getLimitOrderInfoFromSlot(slot);\n        return _lessThan(info.ask, false, key0, key1);\n    }\n\n    function _lessThanBid(\n        uint40 key0,\n        uint40 key1,\n        uint256 slot\n    ) private view returns (bool) {\n        PerpdexStructs.LimitOrderInfo storage info = _getLimitOrderInfoFromSlot(slot);\n        return _lessThan(info.bid, true, key0, key1);\n    }\n\n    function _aggregate(uint40, uint256) private pure returns (bool) {\n        return true;\n    }\n\n    function _subtreeRemoved(uint40, uint256) private pure {}\n\n    function settleLimitOrdersAll(PerpdexStructs.AccountInfo storage accountInfo, uint8 maxMarketsPerAccount) public {\n        address[] storage markets = accountInfo.markets;\n        uint256 i = markets.length;\n        while (i > 0) {\n            --i;\n            _settleLimitOrders(accountInfo, markets[i], maxMarketsPerAccount);\n        }\n    }\n\n    function _settleLimitOrders(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        uint8 maxMarketsPerAccount\n    ) private {\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[market];\n        (\n            AccountPreviewLibrary.Execution[] memory executions,\n            uint40 executedLastAskOrderId,\n            uint40 executedLastBidOrderId\n        ) = AccountPreviewLibrary.getLimitOrderExecutions(accountInfo, market);\n        uint256 executionLength = executions.length;\n        if (executionLength == 0) return;\n\n        {\n            uint256 slot = _getSlot(limitOrderInfo);\n            if (executedLastAskOrderId != 0) {\n                limitOrderInfo.ask.removeLeft(executedLastAskOrderId, _lessThanAsk, _aggregate, _subtreeRemoved, slot);\n            }\n            if (executedLastBidOrderId != 0) {\n                limitOrderInfo.bid.removeLeft(executedLastBidOrderId, _lessThanBid, _aggregate, _subtreeRemoved, slot);\n            }\n        }\n\n        int256 realizedPnl;\n        uint256 totalExecutedBaseAsk;\n        uint256 totalExecutedBaseBid;\n        (\n            accountInfo.takerInfos[market],\n            realizedPnl,\n            totalExecutedBaseAsk,\n            totalExecutedBaseBid\n        ) = AccountPreviewLibrary.previewSettleLimitOrders(accountInfo, market, executions);\n\n        limitOrderInfo.totalBaseAsk -= totalExecutedBaseAsk;\n        limitOrderInfo.totalBaseBid -= totalExecutedBaseBid;\n        accountInfo.limitOrderCount -= executionLength.toUint8();\n        accountInfo.vaultInfo.collateralBalance = accountInfo.vaultInfo.collateralBalance.add(realizedPnl);\n        AccountLibrary.updateMarkets(accountInfo, market, maxMarketsPerAccount);\n    }\n\n    function processPartialExecution(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        bool isBaseToQuote,\n        uint8 maxMarketsPerAccount,\n        IPerpdexMarketMinimum.SwapResponse memory rawResponse\n    ) external returns (int256 realizedPnl) {\n        _settleLimitOrders(accountInfo, market, maxMarketsPerAccount);\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[market];\n        if (isBaseToQuote) {\n            limitOrderInfo.totalBaseBid -= rawResponse.basePartial;\n        } else {\n            limitOrderInfo.totalBaseAsk -= rawResponse.basePartial;\n        }\n        realizedPnl = TakerLibrary.addToTakerBalance(\n            accountInfo,\n            market,\n            isBaseToQuote ? rawResponse.basePartial.toInt256() : rawResponse.basePartial.neg256(),\n            isBaseToQuote ? rawResponse.quotePartial.neg256() : rawResponse.quotePartial.toInt256(),\n            0,\n            maxMarketsPerAccount\n        );\n    }\n\n    function getLimitOrderIds(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        bool isBid\n    ) external view returns (uint40[] memory result) {\n        PerpdexStructs.LimitOrderInfo storage limitOrderInfo = accountInfo.limitOrderInfos[market];\n        RBTreeLibrary.Tree storage tree = isBid ? limitOrderInfo.bid : limitOrderInfo.ask;\n        uint40[256] memory orderIds;\n        uint256 orderCount;\n        uint40 key = tree.first();\n        while (key != 0) {\n            orderIds[orderCount] = key;\n            ++orderCount;\n            key = tree.next(key);\n        }\n        result = new uint40[](orderCount);\n        for (uint256 i = 0; i < orderCount; ++i) {\n            result[i] = orderIds[i];\n        }\n    }\n\n    function _getSlot(PerpdexStructs.LimitOrderInfo storage d) private pure returns (uint256 slot) {\n        assembly {\n            slot := d.slot\n        }\n    }\n\n    function _getLimitOrderInfoFromSlot(uint256 slot) private pure returns (PerpdexStructs.LimitOrderInfo storage d) {\n        assembly {\n            d.slot := slot\n        }\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/TakerLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { IPerpdexMarketMinimum } from \"../interfaces/IPerpdexMarketMinimum.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { PerpdexStructs } from \"./PerpdexStructs.sol\";\nimport { AccountLibrary } from \"./AccountLibrary.sol\";\nimport { AccountPreviewLibrary } from \"./AccountPreviewLibrary.sol\";\n\nlibrary TakerLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct TradeParams {\n        address market;\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amount;\n        uint256 oppositeAmountBound;\n        uint24 mmRatio;\n        uint24 imRatio;\n        uint8 maxMarketsPerAccount;\n        uint24 protocolFeeRatio;\n        bool isSelf;\n        PerpdexStructs.LiquidationRewardConfig liquidationRewardConfig;\n    }\n\n    struct PreviewTradeParams {\n        address market;\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amount;\n        uint256 oppositeAmountBound;\n        uint24 mmRatio;\n        uint24 protocolFeeRatio;\n        bool isSelf;\n    }\n\n    struct TradeResponse {\n        int256 base;\n        int256 quote;\n        int256 realizedPnl;\n        uint256 protocolFee;\n        uint256 liquidationPenalty;\n        uint256 liquidationReward;\n        uint256 insuranceFundReward;\n        bool isLiquidation;\n        IPerpdexMarketMinimum.SwapResponse rawResponse;\n    }\n\n    // to avoid stack too deep\n    struct DoSwapParams {\n        address market;\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amount;\n        uint256 oppositeAmountBound;\n        uint8 maxMarketsPerAccount;\n        uint24 protocolFeeRatio;\n        bool isLiquidation;\n    }\n\n    function trade(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        PerpdexStructs.VaultInfo storage liquidatorVaultInfo,\n        PerpdexStructs.InsuranceFundInfo storage insuranceFundInfo,\n        PerpdexStructs.ProtocolInfo storage protocolInfo,\n        TradeParams memory params\n    ) internal returns (TradeResponse memory response) {\n        response.isLiquidation = _validateTrade(accountInfo, params.market, params.isSelf, params.mmRatio, false);\n\n        int256 takerBaseBefore = accountInfo.takerInfos[params.market].baseBalanceShare;\n\n        (response.base, response.quote, response.realizedPnl, response.protocolFee, response.rawResponse) = _doSwap(\n            accountInfo,\n            protocolInfo,\n            DoSwapParams({\n                market: params.market,\n                isBaseToQuote: params.isBaseToQuote,\n                isExactInput: params.isExactInput,\n                amount: params.amount,\n                oppositeAmountBound: params.oppositeAmountBound,\n                maxMarketsPerAccount: params.maxMarketsPerAccount,\n                protocolFeeRatio: params.protocolFeeRatio,\n                isLiquidation: response.isLiquidation\n            })\n        );\n\n        bool isOpen = (takerBaseBefore.add(response.base)).sign() * response.base.sign() > 0;\n\n        if (response.isLiquidation) {\n            require(!isOpen, \"TL_OP: no open when liquidation\");\n\n            (\n                response.liquidationPenalty,\n                response.liquidationReward,\n                response.insuranceFundReward\n            ) = processLiquidationReward(\n                accountInfo.vaultInfo,\n                liquidatorVaultInfo,\n                insuranceFundInfo,\n                params.mmRatio,\n                params.liquidationRewardConfig,\n                response.quote.abs()\n            );\n        }\n\n        if (isOpen) {\n            require(AccountLibrary.hasEnoughInitialMargin(accountInfo, params.imRatio), \"TL_OP: not enough im\");\n        }\n    }\n\n    function addToTakerBalance(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        int256 baseShare,\n        int256 quoteBalance,\n        int256 quoteFee,\n        uint8 maxMarketsPerAccount\n    ) internal returns (int256 realizedPnl) {\n        (accountInfo.takerInfos[market], realizedPnl) = AccountPreviewLibrary.previewAddToTakerBalance(\n            accountInfo.takerInfos[market],\n            baseShare,\n            quoteBalance,\n            quoteFee\n        );\n\n        accountInfo.vaultInfo.collateralBalance = accountInfo.vaultInfo.collateralBalance.add(realizedPnl);\n\n        AccountLibrary.updateMarkets(accountInfo, market, maxMarketsPerAccount);\n    }\n\n    // Even if trade reverts, it may not revert.\n    // Attempting to match reverts makes the implementation too complicated\n    // ignored checks when liquidation:\n    // - initial margin\n    // - close only\n    // - maker and limit order existence\n    function previewTrade(PerpdexStructs.AccountInfo storage accountInfo, PreviewTradeParams memory params)\n        internal\n        view\n        returns (uint256 oppositeAmount)\n    {\n        bool isLiquidation = _validateTrade(accountInfo, params.market, params.isSelf, params.mmRatio, true);\n\n        oppositeAmount;\n        if (params.protocolFeeRatio == 0) {\n            oppositeAmount = IPerpdexMarketMinimum(params.market).previewSwap(\n                params.isBaseToQuote,\n                params.isExactInput,\n                params.amount,\n                isLiquidation\n            );\n        } else {\n            (oppositeAmount, ) = previewSwapWithProtocolFee(\n                params.market,\n                params.isBaseToQuote,\n                params.isExactInput,\n                params.amount,\n                params.protocolFeeRatio,\n                isLiquidation\n            );\n        }\n        validateSlippage(params.isExactInput, oppositeAmount, params.oppositeAmountBound);\n    }\n\n    // ignored checks when liquidation:\n    // - initial margin\n    // - close only\n    // - maker and limit order existence\n    function maxTrade(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint24 mmRatio,\n        uint24 protocolFeeRatio,\n        bool isSelf\n    ) internal view returns (uint256 amount) {\n        bool isLiquidation = !AccountLibrary.hasEnoughMaintenanceMargin(accountInfo, mmRatio);\n\n        if (!isSelf && !isLiquidation) {\n            return 0;\n        }\n\n        if (protocolFeeRatio == 0) {\n            amount = IPerpdexMarketMinimum(market).maxSwap(isBaseToQuote, isExactInput, isLiquidation);\n        } else {\n            amount = maxSwapWithProtocolFee(market, isBaseToQuote, isExactInput, protocolFeeRatio, isLiquidation);\n        }\n    }\n\n    function _doSwap(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        PerpdexStructs.ProtocolInfo storage protocolInfo,\n        DoSwapParams memory params\n    )\n        private\n        returns (\n            int256 base,\n            int256 quote,\n            int256 realizedPnl,\n            uint256 protocolFee,\n            IPerpdexMarketMinimum.SwapResponse memory rawResponse\n        )\n    {\n        uint256 oppositeAmount;\n\n        if (params.protocolFeeRatio > 0) {\n            (oppositeAmount, protocolFee, rawResponse) = swapWithProtocolFee(\n                protocolInfo,\n                params.market,\n                params.isBaseToQuote,\n                params.isExactInput,\n                params.amount,\n                params.protocolFeeRatio,\n                params.isLiquidation\n            );\n        } else {\n            rawResponse = IPerpdexMarketMinimum(params.market).swap(\n                params.isBaseToQuote,\n                params.isExactInput,\n                params.amount,\n                params.isLiquidation\n            );\n            oppositeAmount = rawResponse.oppositeAmount;\n        }\n        validateSlippage(params.isExactInput, oppositeAmount, params.oppositeAmountBound);\n\n        (base, quote) = swapResponseToBaseQuote(\n            params.isBaseToQuote,\n            params.isExactInput,\n            params.amount,\n            oppositeAmount\n        );\n        realizedPnl = addToTakerBalance(accountInfo, params.market, base, quote, 0, params.maxMarketsPerAccount);\n    }\n\n    function swapWithProtocolFee(\n        PerpdexStructs.ProtocolInfo storage protocolInfo,\n        address market,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        uint24 protocolFeeRatio,\n        bool isLiquidation\n    )\n        internal\n        returns (\n            uint256 oppositeAmount,\n            uint256 protocolFee,\n            IPerpdexMarketMinimum.SwapResponse memory rawResponse\n        )\n    {\n        if (isExactInput) {\n            if (isBaseToQuote) {\n                rawResponse = IPerpdexMarketMinimum(market).swap(isBaseToQuote, isExactInput, amount, isLiquidation);\n                oppositeAmount = rawResponse.oppositeAmount;\n                protocolFee = oppositeAmount.mulRatio(protocolFeeRatio);\n                oppositeAmount = oppositeAmount.sub(protocolFee);\n            } else {\n                protocolFee = amount.mulRatio(protocolFeeRatio);\n                rawResponse = IPerpdexMarketMinimum(market).swap(\n                    isBaseToQuote,\n                    isExactInput,\n                    amount.sub(protocolFee),\n                    isLiquidation\n                );\n                oppositeAmount = rawResponse.oppositeAmount;\n            }\n        } else {\n            if (isBaseToQuote) {\n                protocolFee = amount.divRatio(PerpMath.subRatio(1e6, protocolFeeRatio)).sub(amount);\n                rawResponse = IPerpdexMarketMinimum(market).swap(\n                    isBaseToQuote,\n                    isExactInput,\n                    amount.add(protocolFee),\n                    isLiquidation\n                );\n                oppositeAmount = rawResponse.oppositeAmount;\n            } else {\n                rawResponse = IPerpdexMarketMinimum(market).swap(isBaseToQuote, isExactInput, amount, isLiquidation);\n                uint256 oppositeAmountWithoutFee = rawResponse.oppositeAmount;\n                oppositeAmount = oppositeAmountWithoutFee.divRatio(PerpMath.subRatio(1e6, protocolFeeRatio));\n                protocolFee = oppositeAmount.sub(oppositeAmountWithoutFee);\n            }\n        }\n\n        protocolInfo.protocolFee = protocolInfo.protocolFee.add(protocolFee);\n    }\n\n    function processLiquidationReward(\n        PerpdexStructs.VaultInfo storage vaultInfo,\n        PerpdexStructs.VaultInfo storage liquidatorVaultInfo,\n        PerpdexStructs.InsuranceFundInfo storage insuranceFundInfo,\n        uint24 mmRatio,\n        PerpdexStructs.LiquidationRewardConfig memory liquidationRewardConfig,\n        uint256 exchangedQuote\n    )\n        internal\n        returns (\n            uint256 penalty,\n            uint256 liquidationReward,\n            uint256 insuranceFundReward\n        )\n    {\n        penalty = exchangedQuote.mulRatio(mmRatio);\n        liquidationReward = penalty.mulRatio(liquidationRewardConfig.rewardRatio);\n        insuranceFundReward = penalty.sub(liquidationReward);\n\n        (insuranceFundInfo.liquidationRewardBalance, liquidationReward) = _smoothLiquidationReward(\n            insuranceFundInfo.liquidationRewardBalance,\n            liquidationReward,\n            liquidationRewardConfig.smoothEmaTime\n        );\n\n        vaultInfo.collateralBalance = vaultInfo.collateralBalance.sub(penalty.toInt256());\n        liquidatorVaultInfo.collateralBalance = liquidatorVaultInfo.collateralBalance.add(liquidationReward.toInt256());\n        insuranceFundInfo.balance = insuranceFundInfo.balance.add(insuranceFundReward);\n    }\n\n    function _smoothLiquidationReward(\n        uint256 rewardBalance,\n        uint256 reward,\n        uint24 emaTime\n    ) private pure returns (uint256 outputRewardBalance, uint256 outputReward) {\n        rewardBalance = rewardBalance.add(reward);\n        outputReward = rewardBalance.div(emaTime);\n        outputRewardBalance = rewardBalance.sub(outputReward);\n    }\n\n    function previewSwapWithProtocolFee(\n        address market,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        uint24 protocolFeeRatio,\n        bool isLiquidation\n    ) internal view returns (uint256 oppositeAmount, uint256 protocolFee) {\n        if (isExactInput) {\n            if (isBaseToQuote) {\n                oppositeAmount = IPerpdexMarketMinimum(market).previewSwap(\n                    isBaseToQuote,\n                    isExactInput,\n                    amount,\n                    isLiquidation\n                );\n                protocolFee = oppositeAmount.mulRatio(protocolFeeRatio);\n                oppositeAmount = oppositeAmount.sub(protocolFee);\n            } else {\n                protocolFee = amount.mulRatio(protocolFeeRatio);\n                oppositeAmount = IPerpdexMarketMinimum(market).previewSwap(\n                    isBaseToQuote,\n                    isExactInput,\n                    amount.sub(protocolFee),\n                    isLiquidation\n                );\n            }\n        } else {\n            if (isBaseToQuote) {\n                protocolFee = amount.divRatio(PerpMath.subRatio(1e6, protocolFeeRatio)).sub(amount);\n                oppositeAmount = IPerpdexMarketMinimum(market).previewSwap(\n                    isBaseToQuote,\n                    isExactInput,\n                    amount.add(protocolFee),\n                    isLiquidation\n                );\n            } else {\n                uint256 oppositeAmountWithoutFee =\n                    IPerpdexMarketMinimum(market).previewSwap(isBaseToQuote, isExactInput, amount, isLiquidation);\n                oppositeAmount = oppositeAmountWithoutFee.divRatio(PerpMath.subRatio(1e6, protocolFeeRatio));\n                protocolFee = oppositeAmount.sub(oppositeAmountWithoutFee);\n            }\n        }\n    }\n\n    function maxSwapWithProtocolFee(\n        address market,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint24 protocolFeeRatio,\n        bool isLiquidation\n    ) internal view returns (uint256 amount) {\n        amount = IPerpdexMarketMinimum(market).maxSwap(isBaseToQuote, isExactInput, isLiquidation);\n\n        if (isExactInput) {\n            if (isBaseToQuote) {} else {\n                amount = amount.divRatio(PerpMath.subRatio(1e6, protocolFeeRatio));\n            }\n        } else {\n            if (isBaseToQuote) {\n                amount = amount.mulRatio(PerpMath.subRatio(1e6, protocolFeeRatio));\n            } else {}\n        }\n    }\n\n    function validateSlippage(\n        bool isExactInput,\n        uint256 oppositeAmount,\n        uint256 oppositeAmountBound\n    ) internal pure {\n        if (isExactInput) {\n            require(oppositeAmount >= oppositeAmountBound, \"TL_VS: too small opposite amount\");\n        } else {\n            require(oppositeAmount <= oppositeAmountBound, \"TL_VS: too large opposite amount\");\n        }\n    }\n\n    function swapResponseToBaseQuote(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        uint256 oppositeAmount\n    ) internal pure returns (int256, int256) {\n        if (isExactInput) {\n            if (isBaseToQuote) {\n                return (amount.neg256(), oppositeAmount.toInt256());\n            } else {\n                return (oppositeAmount.toInt256(), amount.neg256());\n            }\n        } else {\n            if (isBaseToQuote) {\n                return (oppositeAmount.neg256(), amount.toInt256());\n            } else {\n                return (amount.toInt256(), oppositeAmount.neg256());\n            }\n        }\n    }\n\n    function _validateTrade(\n        PerpdexStructs.AccountInfo storage accountInfo,\n        address market,\n        bool isSelf,\n        uint24 mmRatio,\n        bool ignoreMakerOrderBookExistence\n    ) private view returns (bool isLiquidation) {\n        isLiquidation = !AccountLibrary.hasEnoughMaintenanceMargin(accountInfo, mmRatio);\n\n        if (!isSelf) {\n            require(isLiquidation, \"TL_VT: enough mm\");\n        }\n\n        if (!ignoreMakerOrderBookExistence && isLiquidation) {\n            require(accountInfo.makerInfos[market].liquidity == 0, \"TL_VT: no maker when liquidation\");\n            require(accountInfo.limitOrderInfos[market].ask.root == 0, \"TL_VT: no ask when liquidation\");\n            require(accountInfo.limitOrderInfos[market].bid.root == 0, \"TL_VT: no bid when liquidation\");\n        }\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/OrderBookLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { MarketStructs } from \"./MarketStructs.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport {\n    BokkyPooBahsRedBlackTreeLibrary as RBTreeLibrary\n} from \"../../deps/BokkyPooBahsRedBlackTreeLibrary/contracts/BokkyPooBahsRedBlackTreeLibrary.sol\";\n\nlibrary OrderBookLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using RBTreeLibrary for RBTreeLibrary.Tree;\n\n    struct SwapResponse {\n        uint256 oppositeAmount;\n        uint256 basePartial;\n        uint256 quotePartial;\n        uint40 partialKey;\n        uint40 fullLastKey;\n    }\n\n    // to avoid stack too deep\n    struct PreviewSwapParams {\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amount;\n        uint256 baseBalancePerShareX96;\n    }\n\n    // to avoid stack too deep\n    struct PreviewSwapLocalVars {\n        uint128 priceX96;\n        uint256 sharePriceX96;\n        uint256 amountPool;\n        uint40 left;\n        uint40 right;\n        uint256 leftBaseSum;\n        uint256 leftQuoteSum;\n        uint256 rightBaseSum;\n        uint256 rightQuoteSum;\n    }\n\n    struct PreviewSwapResponse {\n        uint256 amountPool;\n        uint256 baseFull;\n        uint256 quoteFull;\n        uint256 basePartial;\n        uint256 quotePartial;\n        uint40 fullLastKey;\n        uint40 partialKey;\n    }\n\n    function createOrder(\n        MarketStructs.OrderBookInfo storage orderBookInfo,\n        bool isBid,\n        uint256 base,\n        uint256 priceX96\n    ) public returns (uint40) {\n        require(base > 0, \"OBL_CO: base is zero\");\n        require(priceX96 > 0, \"OBL_CO: price is zero\");\n        MarketStructs.OrderBookSideInfo storage info = isBid ? orderBookInfo.bid : orderBookInfo.ask;\n        uint40 key = info.seqKey + 1;\n        info.seqKey = key;\n        info.orderInfos[key].base = base; // before insert for aggregation\n        uint128 userData = _makeUserData(priceX96);\n        uint256 slot = _getSlot(orderBookInfo);\n        if (isBid) {\n            info.tree.insert(key, userData, _lessThanBid, _aggregateBid, slot);\n        } else {\n            info.tree.insert(key, userData, _lessThanAsk, _aggregateAsk, slot);\n        }\n        return key;\n    }\n\n    function cancelOrder(\n        MarketStructs.OrderBookInfo storage orderBookInfo,\n        bool isBid,\n        uint40 key\n    ) public {\n        MarketStructs.OrderBookSideInfo storage info = isBid ? orderBookInfo.bid : orderBookInfo.ask;\n        require(_isFullyExecuted(info, key) == 0, \"OBL_CO: already fully executed\");\n        uint256 slot = _getSlot(orderBookInfo);\n        if (isBid) {\n            info.tree.remove(key, _aggregateBid, slot);\n        } else {\n            info.tree.remove(key, _aggregateAsk, slot);\n        }\n        delete info.orderInfos[key];\n    }\n\n    function getOrderInfo(\n        MarketStructs.OrderBookInfo storage orderBookInfo,\n        bool isBid,\n        uint40 key\n    ) public view returns (uint256 base, uint256 priceX96) {\n        MarketStructs.OrderBookSideInfo storage info = isBid ? orderBookInfo.bid : orderBookInfo.ask;\n        base = info.orderInfos[key].base;\n        priceX96 = _userDataToPriceX96(info.tree.nodes[key].userData);\n    }\n\n    function getOrderExecution(\n        MarketStructs.OrderBookInfo storage orderBookInfo,\n        bool isBid,\n        uint40 key\n    )\n        public\n        view\n        returns (\n            uint48 executionId,\n            uint256 executedBase,\n            uint256 executedQuote\n        )\n    {\n        MarketStructs.OrderBookSideInfo storage info = isBid ? orderBookInfo.bid : orderBookInfo.ask;\n        executionId = _isFullyExecuted(info, key);\n        if (executionId == 0) return (0, 0, 0);\n\n        executedBase = info.orderInfos[key].base;\n        // rounding error occurs, but it is negligible.\n\n        executedQuote = _quoteToBalance(\n            _getQuote(info, key),\n            orderBookInfo.executionInfos[executionId].baseBalancePerShareX96\n        );\n    }\n\n    function getBestPriceX96(MarketStructs.OrderBookSideInfo storage info) external view returns (uint256) {\n        if (info.tree.root == 0) return 0;\n        uint40 key = info.tree.first();\n        return _userDataToPriceX96(info.tree.nodes[key].userData);\n    }\n\n    function swap(\n        MarketStructs.OrderBookInfo storage orderBookInfo,\n        PreviewSwapParams memory params,\n        function(bool, bool, uint256) view returns (uint256) maxSwapArg,\n        function(bool, bool, uint256) returns (uint256) swapArg\n    ) internal returns (SwapResponse memory swapResponse) {\n        MarketStructs.OrderBookSideInfo storage info = params.isBaseToQuote ? orderBookInfo.bid : orderBookInfo.ask;\n        PreviewSwapResponse memory response = previewSwap(info, params, maxSwapArg);\n\n        if (response.amountPool > 0) {\n            swapResponse.oppositeAmount += swapArg(params.isBaseToQuote, params.isExactInput, response.amountPool);\n        }\n\n        bool isBase = params.isBaseToQuote == params.isExactInput;\n        uint256 slot = _getSlot(orderBookInfo);\n\n        if (response.fullLastKey != 0) {\n            orderBookInfo.seqExecutionId += 1;\n            orderBookInfo.executionInfos[orderBookInfo.seqExecutionId] = MarketStructs.ExecutionInfo({\n                baseBalancePerShareX96: params.baseBalancePerShareX96\n            });\n            if (params.isBaseToQuote) {\n                info.tree.removeLeft(response.fullLastKey, _lessThanBid, _aggregateBid, _subtreeRemovedBid, slot);\n            } else {\n                info.tree.removeLeft(response.fullLastKey, _lessThanAsk, _aggregateAsk, _subtreeRemovedAsk, slot);\n            }\n\n            swapResponse.oppositeAmount += isBase ? response.quoteFull : response.baseFull;\n            swapResponse.fullLastKey = response.fullLastKey;\n        } else {\n            require(response.baseFull == 0, \"never occur\");\n            require(response.quoteFull == 0, \"never occur\");\n        }\n\n        if (response.partialKey != 0) {\n            info.orderInfos[response.partialKey].base -= response.basePartial;\n            require(info.orderInfos[response.partialKey].base > 0, \"never occur\");\n\n            info.tree.aggregateRecursively(\n                response.partialKey,\n                params.isBaseToQuote ? _aggregateBid : _aggregateAsk,\n                slot\n            );\n\n            swapResponse.oppositeAmount += isBase ? response.quotePartial : response.basePartial;\n            swapResponse.basePartial = response.basePartial;\n            swapResponse.quotePartial = response.quotePartial;\n            swapResponse.partialKey = response.partialKey;\n        } else {\n            require(response.basePartial == 0, \"never occur\");\n            require(response.quotePartial == 0, \"never occur\");\n        }\n    }\n\n    function previewSwap(\n        MarketStructs.OrderBookSideInfo storage info,\n        PreviewSwapParams memory params,\n        function(bool, bool, uint256) view returns (uint256) maxSwapArg\n    ) internal view returns (PreviewSwapResponse memory response) {\n        bool isBase = params.isBaseToQuote == params.isExactInput;\n        uint40 key = info.tree.root;\n        uint256 baseSum;\n        uint256 quoteSum;\n\n        while (key != 0) {\n            PreviewSwapLocalVars memory vars;\n            vars.priceX96 = _userDataToPriceX96(info.tree.nodes[key].userData);\n            vars.sharePriceX96 = Math.mulDiv(vars.priceX96, params.baseBalancePerShareX96, FixedPoint96.Q96);\n            vars.amountPool = maxSwapArg(params.isBaseToQuote, params.isExactInput, vars.sharePriceX96);\n\n            // key - right is more gas efficient than left + key\n            vars.left = info.tree.nodes[key].left;\n            vars.right = info.tree.nodes[key].right;\n            vars.leftBaseSum = baseSum + info.orderInfos[vars.left].baseSum;\n            vars.leftQuoteSum = quoteSum + info.orderInfos[vars.left].quoteSum;\n\n            uint256 rangeLeft =\n                (isBase ? vars.leftBaseSum : _quoteToBalance(vars.leftQuoteSum, params.baseBalancePerShareX96)) +\n                    vars.amountPool;\n            if (params.amount <= rangeLeft) {\n                if (vars.left == 0) {\n                    response.fullLastKey = info.tree.prev(key);\n                }\n                key = vars.left;\n                continue;\n            }\n\n            vars.rightBaseSum = baseSum + (info.orderInfos[key].baseSum - info.orderInfos[vars.right].baseSum);\n            vars.rightQuoteSum = quoteSum + (info.orderInfos[key].quoteSum - info.orderInfos[vars.right].quoteSum);\n\n            uint256 rangeRight =\n                (isBase ? vars.rightBaseSum : _quoteToBalance(vars.rightQuoteSum, params.baseBalancePerShareX96)) +\n                    vars.amountPool;\n            if (params.amount < rangeRight) {\n                response.amountPool = vars.amountPool;\n                response.baseFull = vars.leftBaseSum;\n                response.quoteFull = _quoteToBalance(vars.leftQuoteSum, params.baseBalancePerShareX96);\n                if (isBase) {\n                    response.basePartial = params.amount - rangeLeft; // < info.orderInfos[key].base\n                    response.quotePartial = Math.mulDiv(response.basePartial, vars.sharePriceX96, FixedPoint96.Q96);\n                } else {\n                    response.quotePartial = params.amount - rangeLeft;\n                    response.basePartial = Math.mulDiv(response.quotePartial, FixedPoint96.Q96, vars.sharePriceX96);\n                    // round to fit order size\n                    response.basePartial = Math.min(response.basePartial, info.orderInfos[key].base - 1);\n                }\n                response.fullLastKey = info.tree.prev(key);\n                response.partialKey = key;\n                return response;\n            }\n\n            {\n                baseSum = vars.rightBaseSum;\n                quoteSum = vars.rightQuoteSum;\n                if (vars.right == 0) {\n                    response.fullLastKey = key;\n                }\n                key = vars.right;\n            }\n        }\n\n        response.baseFull = baseSum;\n        response.quoteFull = _quoteToBalance(quoteSum, params.baseBalancePerShareX96);\n        response.amountPool = params.amount - (isBase ? response.baseFull : response.quoteFull);\n    }\n\n    function maxSwap(\n        MarketStructs.OrderBookSideInfo storage info,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 sharePriceBoundX96,\n        uint256 baseBalancePerShareX96\n    ) public view returns (uint256 amount) {\n        uint256 priceBoundX96 = Math.mulDiv(sharePriceBoundX96, FixedPoint96.Q96, baseBalancePerShareX96);\n        bool isBid = isBaseToQuote;\n        bool isBase = isBaseToQuote == isExactInput;\n        uint40 key = info.tree.root;\n\n        while (key != 0) {\n            uint128 price = _userDataToPriceX96(info.tree.nodes[key].userData);\n            uint40 left = info.tree.nodes[key].left;\n            if (isBid ? price >= priceBoundX96 : price <= priceBoundX96) {\n                // key - right is more gas efficient than left + key\n                uint40 right = info.tree.nodes[key].right;\n                amount += isBase\n                    ? info.orderInfos[key].baseSum - info.orderInfos[right].baseSum\n                    : info.orderInfos[key].quoteSum - info.orderInfos[right].quoteSum;\n                key = right;\n            } else {\n                key = left;\n            }\n        }\n\n        if (!isBase) {\n            amount = _quoteToBalance(amount, baseBalancePerShareX96);\n        }\n    }\n\n    function _isFullyExecuted(MarketStructs.OrderBookSideInfo storage info, uint40 key) private view returns (uint48) {\n        uint40 root = info.tree.root;\n        while (key != 0 && key != root) {\n            if (info.orderInfos[key].executionId != 0) {\n                return info.orderInfos[key].executionId;\n            }\n            key = info.tree.nodes[key].parent;\n        }\n        return 0;\n    }\n\n    function _makeUserData(uint256 priceX96) private pure returns (uint128) {\n        return priceX96.toUint128();\n    }\n\n    function _userDataToPriceX96(uint128 userData) private pure returns (uint128) {\n        return userData;\n    }\n\n    function _lessThan(\n        RBTreeLibrary.Tree storage tree,\n        bool isBid,\n        uint40 key0,\n        uint40 key1\n    ) private view returns (bool) {\n        uint128 price0 = _userDataToPriceX96(tree.nodes[key0].userData);\n        uint128 price1 = _userDataToPriceX96(tree.nodes[key1].userData);\n        if (price0 == price1) {\n            return key0 < key1; // time priority\n        }\n        // price priority\n        return isBid ? price0 > price1 : price0 < price1;\n    }\n\n    function _lessThanAsk(\n        uint40 key0,\n        uint40 key1,\n        uint256 slot\n    ) private view returns (bool) {\n        MarketStructs.OrderBookInfo storage info = _getOrderBookInfoFromSlot(slot);\n        return _lessThan(info.ask.tree, false, key0, key1);\n    }\n\n    function _lessThanBid(\n        uint40 key0,\n        uint40 key1,\n        uint256 slot\n    ) private view returns (bool) {\n        MarketStructs.OrderBookInfo storage info = _getOrderBookInfoFromSlot(slot);\n        return _lessThan(info.bid.tree, true, key0, key1);\n    }\n\n    function _aggregate(MarketStructs.OrderBookSideInfo storage info, uint40 key) private returns (bool stop) {\n        uint256 prevBaseSum = info.orderInfos[key].baseSum;\n        uint256 prevQuoteSum = info.orderInfos[key].quoteSum;\n        uint40 left = info.tree.nodes[key].left;\n        uint40 right = info.tree.nodes[key].right;\n\n        uint256 baseSum = info.orderInfos[left].baseSum + info.orderInfos[right].baseSum + info.orderInfos[key].base;\n        uint256 quoteSum = info.orderInfos[left].quoteSum + info.orderInfos[right].quoteSum + _getQuote(info, key);\n\n        stop = baseSum == prevBaseSum && quoteSum == prevQuoteSum;\n        if (!stop) {\n            info.orderInfos[key].baseSum = baseSum;\n            info.orderInfos[key].quoteSum = quoteSum;\n        }\n    }\n\n    function _aggregateAsk(uint40 key, uint256 slot) private returns (bool stop) {\n        MarketStructs.OrderBookInfo storage info = _getOrderBookInfoFromSlot(slot);\n        return _aggregate(info.ask, key);\n    }\n\n    function _aggregateBid(uint40 key, uint256 slot) private returns (bool stop) {\n        MarketStructs.OrderBookInfo storage info = _getOrderBookInfoFromSlot(slot);\n        return _aggregate(info.bid, key);\n    }\n\n    function _subtreeRemoved(\n        MarketStructs.OrderBookSideInfo storage info,\n        MarketStructs.OrderBookInfo storage orderBookInfo,\n        uint40 key\n    ) private {\n        info.orderInfos[key].executionId = orderBookInfo.seqExecutionId;\n    }\n\n    function _subtreeRemovedAsk(uint40 key, uint256 slot) private {\n        MarketStructs.OrderBookInfo storage info = _getOrderBookInfoFromSlot(slot);\n        return _subtreeRemoved(info.ask, info, key);\n    }\n\n    function _subtreeRemovedBid(uint40 key, uint256 slot) private {\n        MarketStructs.OrderBookInfo storage info = _getOrderBookInfoFromSlot(slot);\n        return _subtreeRemoved(info.bid, info, key);\n    }\n\n    // returns quoteBalance / baseBalancePerShare\n    function _getQuote(MarketStructs.OrderBookSideInfo storage info, uint40 key) private view returns (uint256) {\n        uint128 priceX96 = _userDataToPriceX96(info.tree.nodes[key].userData);\n        return Math.mulDiv(info.orderInfos[key].base, priceX96, FixedPoint96.Q96);\n    }\n\n    function _quoteToBalance(uint256 quote, uint256 baseBalancePerShareX96) private pure returns (uint256) {\n        return Math.mulDiv(quote, baseBalancePerShareX96, FixedPoint96.Q96);\n    }\n\n    function _getSlot(MarketStructs.OrderBookInfo storage d) private pure returns (uint256 slot) {\n        assembly {\n            slot := d.slot\n        }\n    }\n\n    function _getOrderBookInfoFromSlot(uint256 slot) private pure returns (MarketStructs.OrderBookInfo storage d) {\n        assembly {\n            d.slot := slot\n        }\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/MarketStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\n\nimport {\n    BokkyPooBahsRedBlackTreeLibrary as RBTreeLibrary\n} from \"../../deps/BokkyPooBahsRedBlackTreeLibrary/contracts/BokkyPooBahsRedBlackTreeLibrary.sol\";\n\nlibrary MarketStructs {\n    struct FundingInfo {\n        uint256 prevIndexPriceBase;\n        uint256 prevIndexPriceQuote;\n        uint256 prevIndexPriceTimestamp;\n    }\n\n    struct PoolInfo {\n        uint256 base;\n        uint256 quote;\n        uint256 totalLiquidity;\n        uint256 cumBasePerLiquidityX96;\n        uint256 cumQuotePerLiquidityX96;\n        uint256 baseBalancePerShareX96;\n    }\n\n    struct PriceLimitInfo {\n        uint256 referencePrice;\n        uint256 referenceTimestamp;\n        uint256 emaPrice;\n    }\n\n    struct PriceLimitConfig {\n        uint24 normalOrderRatio;\n        uint24 liquidationRatio;\n        uint24 emaNormalOrderRatio;\n        uint24 emaLiquidationRatio;\n        uint32 emaSec;\n    }\n\n    struct OrderInfo {\n        uint256 base;\n        uint256 baseSum;\n        uint256 quoteSum;\n        uint48 executionId;\n    }\n\n    struct OrderBookSideInfo {\n        RBTreeLibrary.Tree tree;\n        mapping(uint40 => OrderInfo) orderInfos;\n        uint40 seqKey;\n    }\n\n    struct ExecutionInfo {\n        uint256 baseBalancePerShareX96;\n    }\n\n    struct OrderBookInfo {\n        OrderBookSideInfo ask;\n        OrderBookSideInfo bid;\n        uint48 seqExecutionId;\n        mapping(uint48 => ExecutionInfo) executionInfos;\n    }\n\n    struct PoolFeeInfo {\n        uint256 atrX96;\n        uint256 referenceTimestamp;\n        uint256 currentHighX96;\n        uint256 currentLowX96;\n    }\n\n    struct PoolFeeConfig {\n        uint24 fixedFeeRatio;\n        uint24 atrFeeRatio;\n        uint32 atrEmaBlocks;\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/PoolFeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { MarketStructs } from \"./MarketStructs.sol\";\n\nlibrary PoolFeeLibrary {\n    using PerpMath for uint256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    function update(\n        MarketStructs.PoolFeeInfo storage poolFeeInfo,\n        uint32 atrEmaBlocks,\n        uint256 prevPriceX96,\n        uint256 currentPriceX96\n    ) internal {\n        uint256 currentTimestamp = block.timestamp;\n\n        if (currentTimestamp <= poolFeeInfo.referenceTimestamp) {\n            poolFeeInfo.currentHighX96 = Math.max(poolFeeInfo.currentHighX96, currentPriceX96);\n            poolFeeInfo.currentLowX96 = Math.min(poolFeeInfo.currentLowX96, currentPriceX96);\n        } else {\n            poolFeeInfo.referenceTimestamp = currentTimestamp;\n            poolFeeInfo.atrX96 = _calculateAtrX96(poolFeeInfo, atrEmaBlocks);\n            poolFeeInfo.currentHighX96 = Math.max(prevPriceX96, currentPriceX96);\n            poolFeeInfo.currentLowX96 = Math.min(prevPriceX96, currentPriceX96);\n        }\n    }\n\n    function feeRatio(MarketStructs.PoolFeeInfo storage poolFeeInfo, MarketStructs.PoolFeeConfig memory config)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 atrX96 = _calculateAtrX96(poolFeeInfo, config.atrEmaBlocks);\n        return Math.mulDiv(config.atrFeeRatio, atrX96, FixedPoint96.Q96).add(config.fixedFeeRatio);\n    }\n\n    function _calculateAtrX96(MarketStructs.PoolFeeInfo storage poolFeeInfo, uint32 atrEmaBlocks)\n        private\n        view\n        returns (uint256)\n    {\n        if (poolFeeInfo.currentLowX96 == 0) return 0;\n        uint256 trX96 =\n            Math.mulDiv(poolFeeInfo.currentHighX96, FixedPoint96.Q96, poolFeeInfo.currentLowX96).sub(FixedPoint96.Q96);\n        uint256 denominator = atrEmaBlocks + 1;\n        return Math.mulDiv(poolFeeInfo.atrX96, atrEmaBlocks, denominator).add(trX96.div(denominator));\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/PriceLimitLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { MarketStructs } from \"./MarketStructs.sol\";\n\nlibrary PriceLimitLibrary {\n    using PerpMath for uint256;\n    using SafeMath for uint256;\n\n    function update(MarketStructs.PriceLimitInfo storage priceLimitInfo, MarketStructs.PriceLimitInfo memory value)\n        internal\n    {\n        if (value.referenceTimestamp == 0) return;\n        priceLimitInfo.referencePrice = value.referencePrice;\n        priceLimitInfo.referenceTimestamp = value.referenceTimestamp;\n        priceLimitInfo.emaPrice = value.emaPrice;\n    }\n\n    // referenceTimestamp == 0 indicates not updated\n    function updateDry(\n        MarketStructs.PriceLimitInfo storage priceLimitInfo,\n        MarketStructs.PriceLimitConfig storage config,\n        uint256 price\n    ) internal view returns (MarketStructs.PriceLimitInfo memory updated) {\n        uint256 currentTimestamp = block.timestamp;\n        uint256 refTimestamp = priceLimitInfo.referenceTimestamp;\n        if (currentTimestamp <= refTimestamp) {\n            updated.referencePrice = priceLimitInfo.referencePrice;\n            updated.emaPrice = priceLimitInfo.emaPrice;\n            return updated;\n        }\n\n        uint256 elapsed = currentTimestamp.sub(refTimestamp);\n\n        if (priceLimitInfo.referencePrice == 0) {\n            updated.emaPrice = price;\n        } else {\n            uint32 emaSec = config.emaSec;\n            uint256 denominator = elapsed.add(emaSec);\n            updated.emaPrice = Math.mulDiv(priceLimitInfo.emaPrice, emaSec, denominator).add(\n                Math.mulDiv(price, elapsed, denominator)\n            );\n        }\n\n        updated.referencePrice = price;\n        updated.referenceTimestamp = currentTimestamp;\n    }\n\n    function priceBound(\n        uint256 referencePrice,\n        uint256 emaPrice,\n        MarketStructs.PriceLimitConfig storage config,\n        bool isLiquidation,\n        bool isUpperBound\n    ) internal view returns (uint256 price) {\n        uint256 referenceRange =\n            referencePrice.mulRatio(isLiquidation ? config.liquidationRatio : config.normalOrderRatio);\n        uint256 emaRange = emaPrice.mulRatio(isLiquidation ? config.emaLiquidationRatio : config.emaNormalOrderRatio);\n\n        if (isUpperBound) {\n            return Math.min(referencePrice.add(referenceRange), emaPrice.add(emaRange));\n        } else {\n            return Math.max(referencePrice.sub(referenceRange), emaPrice.sub(emaRange));\n        }\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/PoolLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { MarketStructs } from \"./MarketStructs.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\n\nlibrary PoolLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct SwapParams {\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint24 feeRatio;\n        uint256 amount;\n    }\n\n    struct AddLiquidityParams {\n        uint256 base;\n        uint256 quote;\n    }\n\n    struct RemoveLiquidityParams {\n        uint256 liquidity;\n    }\n\n    uint256 public constant MINIMUM_LIQUIDITY = 1e3;\n\n    function initializePool(MarketStructs.PoolInfo storage poolInfo) internal {\n        poolInfo.baseBalancePerShareX96 = FixedPoint96.Q96;\n    }\n\n    // underestimate deleveraged tokens\n    function applyFunding(MarketStructs.PoolInfo storage poolInfo, int256 fundingRateX96) internal {\n        if (fundingRateX96 == 0) return;\n\n        uint256 frAbs = fundingRateX96.abs();\n\n        if (fundingRateX96 > 0) {\n            uint256 poolQuote = poolInfo.quote;\n            uint256 deleveratedQuote = Math.mulDiv(poolQuote, frAbs, FixedPoint96.Q96);\n            poolInfo.quote = poolQuote.sub(deleveratedQuote);\n            poolInfo.cumQuotePerLiquidityX96 = poolInfo.cumQuotePerLiquidityX96.add(\n                Math.mulDiv(deleveratedQuote, FixedPoint96.Q96, poolInfo.totalLiquidity)\n            );\n        } else {\n            uint256 poolBase = poolInfo.base;\n            uint256 deleveratedBase = Math.mulDiv(poolBase, frAbs, FixedPoint96.Q96.add(frAbs));\n            poolInfo.base = poolBase.sub(deleveratedBase);\n            poolInfo.cumBasePerLiquidityX96 = poolInfo.cumBasePerLiquidityX96.add(\n                Math.mulDiv(deleveratedBase, FixedPoint96.Q96, poolInfo.totalLiquidity)\n            );\n        }\n\n        poolInfo.baseBalancePerShareX96 = Math.mulDiv(\n            poolInfo.baseBalancePerShareX96,\n            FixedPoint96.Q96.toInt256().sub(fundingRateX96).toUint256(),\n            FixedPoint96.Q96\n        );\n    }\n\n    function swap(MarketStructs.PoolInfo storage poolInfo, SwapParams memory params)\n        internal\n        returns (uint256 oppositeAmount)\n    {\n        oppositeAmount = previewSwap(poolInfo.base, poolInfo.quote, params);\n        (poolInfo.base, poolInfo.quote) = calcPoolAfter(\n            params.isBaseToQuote,\n            params.isExactInput,\n            poolInfo.base,\n            poolInfo.quote,\n            params.amount,\n            oppositeAmount\n        );\n    }\n\n    function calcPoolAfter(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 base,\n        uint256 quote,\n        uint256 amount,\n        uint256 oppositeAmount\n    ) internal pure returns (uint256 baseAfter, uint256 quoteAfter) {\n        if (isExactInput) {\n            if (isBaseToQuote) {\n                baseAfter = base.add(amount);\n                quoteAfter = quote.sub(oppositeAmount);\n            } else {\n                baseAfter = base.sub(oppositeAmount);\n                quoteAfter = quote.add(amount);\n            }\n        } else {\n            if (isBaseToQuote) {\n                baseAfter = base.add(oppositeAmount);\n                quoteAfter = quote.sub(amount);\n            } else {\n                baseAfter = base.sub(amount);\n                quoteAfter = quote.add(oppositeAmount);\n            }\n        }\n    }\n\n    function addLiquidity(MarketStructs.PoolInfo storage poolInfo, AddLiquidityParams memory params)\n        internal\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 poolTotalLiquidity = poolInfo.totalLiquidity;\n        uint256 liquidity;\n\n        if (poolTotalLiquidity == 0) {\n            uint256 totalLiquidity = Math.sqrt(params.base.mul(params.quote));\n            liquidity = totalLiquidity.sub(MINIMUM_LIQUIDITY);\n            require(params.base > 0 && params.quote > 0 && liquidity > 0, \"PL_AL: initial liquidity zero\");\n\n            poolInfo.base = params.base;\n            poolInfo.quote = params.quote;\n            poolInfo.totalLiquidity = totalLiquidity;\n            return (params.base, params.quote, liquidity);\n        }\n\n        uint256 poolBase = poolInfo.base;\n        uint256 poolQuote = poolInfo.quote;\n\n        uint256 base = Math.min(params.base, Math.mulDiv(params.quote, poolBase, poolQuote));\n        uint256 quote = Math.min(params.quote, Math.mulDiv(params.base, poolQuote, poolBase));\n        liquidity = Math.min(\n            Math.mulDiv(base, poolTotalLiquidity, poolBase),\n            Math.mulDiv(quote, poolTotalLiquidity, poolQuote)\n        );\n        require(base > 0 && quote > 0 && liquidity > 0, \"PL_AL: liquidity zero\");\n\n        poolInfo.base = poolBase.add(base);\n        poolInfo.quote = poolQuote.add(quote);\n        poolInfo.totalLiquidity = poolTotalLiquidity.add(liquidity);\n\n        return (base, quote, liquidity);\n    }\n\n    function removeLiquidity(MarketStructs.PoolInfo storage poolInfo, RemoveLiquidityParams memory params)\n        internal\n        returns (uint256, uint256)\n    {\n        uint256 poolBase = poolInfo.base;\n        uint256 poolQuote = poolInfo.quote;\n        uint256 poolTotalLiquidity = poolInfo.totalLiquidity;\n        uint256 base = Math.mulDiv(params.liquidity, poolBase, poolTotalLiquidity);\n        uint256 quote = Math.mulDiv(params.liquidity, poolQuote, poolTotalLiquidity);\n        require(base > 0 && quote > 0, \"PL_RL: output is zero\");\n        poolInfo.base = poolBase.sub(base);\n        poolInfo.quote = poolQuote.sub(quote);\n        uint256 totalLiquidity = poolTotalLiquidity.sub(params.liquidity);\n        require(totalLiquidity >= MINIMUM_LIQUIDITY, \"PL_RL: min liquidity\");\n        poolInfo.totalLiquidity = totalLiquidity;\n        return (base, quote);\n    }\n\n    function getLiquidityValue(MarketStructs.PoolInfo storage poolInfo, uint256 liquidity)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            Math.mulDiv(liquidity, poolInfo.base, poolInfo.totalLiquidity),\n            Math.mulDiv(liquidity, poolInfo.quote, poolInfo.totalLiquidity)\n        );\n    }\n\n    // subtract fee from input before swap\n    function previewSwap(\n        uint256 base,\n        uint256 quote,\n        SwapParams memory params\n    ) internal pure returns (uint256 output) {\n        uint24 oneSubFeeRatio = PerpMath.subRatio(1e6, params.feeRatio);\n\n        if (params.isExactInput) {\n            uint256 amountSubFee = params.amount.mulRatio(oneSubFeeRatio);\n            if (params.isBaseToQuote) {\n                // output = quote.sub(FullMath.mulDivRoundingUp(base, quote, base.add(amountSubFee)));\n                output = Math.mulDiv(quote, amountSubFee, base.add(amountSubFee));\n            } else {\n                // output = base.sub(FullMath.mulDivRoundingUp(base, quote, quote.add(amountSubFee)));\n                output = Math.mulDiv(base, amountSubFee, quote.add(amountSubFee));\n            }\n        } else {\n            if (params.isBaseToQuote) {\n                // output = FullMath.mulDivRoundingUp(base, quote, quote.sub(params.amount)).sub(base);\n                output = Math.mulDiv(base, params.amount, quote.sub(params.amount), Math.Rounding.Up);\n            } else {\n                // output = FullMath.mulDivRoundingUp(base, quote, base.sub(params.amount)).sub(quote);\n                output = Math.mulDiv(quote, params.amount, base.sub(params.amount), Math.Rounding.Up);\n            }\n            output = output.divRatioRoundingUp(oneSubFeeRatio);\n        }\n    }\n\n    function _solveQuadratic(uint256 b, uint256 cNeg) private pure returns (uint256) {\n        return Math.sqrt(b.mul(b).add(cNeg.mul(4))).sub(b).div(2);\n    }\n\n    function getAskPriceX96(uint256 priceX96, uint24 feeRatio) internal pure returns (uint256) {\n        uint24 oneSubFeeRatio = PerpMath.subRatio(1e6, feeRatio);\n        return priceX96.divRatio(oneSubFeeRatio);\n    }\n\n    function getBidPriceX96(uint256 priceX96, uint24 feeRatio) internal pure returns (uint256) {\n        uint24 oneSubFeeRatio = PerpMath.subRatio(1e6, feeRatio);\n        return priceX96.mulRatioRoundingUp(oneSubFeeRatio);\n    }\n\n    // must not revert\n    // Trade until the trade price including fee (dy/dx) reaches priceBoundX96\n    // not pool price (y/x)\n    // long: trade_price = pool_price / (1 - fee)\n    // short: trade_price = pool_price * (1 - fee)\n    function maxSwap(\n        uint256 base,\n        uint256 quote,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint24 feeRatio,\n        uint256 priceBoundX96\n    ) internal pure returns (uint256 output) {\n        uint24 oneSubFeeRatio = PerpMath.subRatio(1e6, feeRatio);\n        uint256 k = base.mul(quote);\n\n        if (isBaseToQuote) {\n            uint256 kDivP = Math.mulDiv(k, FixedPoint96.Q96, priceBoundX96).mulRatio(oneSubFeeRatio);\n            uint256 baseSqr = base.mul(base);\n            if (kDivP <= baseSqr) return 0;\n            uint256 cNeg = kDivP.sub(baseSqr);\n            uint256 b = base.add(base.mulRatio(oneSubFeeRatio));\n            output = _solveQuadratic(b.divRatio(oneSubFeeRatio), cNeg.divRatio(oneSubFeeRatio));\n        } else {\n            // https://www.wolframalpha.com/input?i=%28x+%2B+a%29+*+%28x+%2B+a+*+%281+-+f%29%29+%3D+kp+solve+a\n            uint256 kp = Math.mulDiv(k, priceBoundX96, FixedPoint96.Q96).mulRatio(oneSubFeeRatio);\n            uint256 quoteSqr = quote.mul(quote);\n            if (kp <= quoteSqr) return 0;\n            uint256 cNeg = kp.sub(quoteSqr);\n            uint256 b = quote.add(quote.mulRatio(oneSubFeeRatio));\n            output = _solveQuadratic(b.divRatio(oneSubFeeRatio), cNeg.divRatio(oneSubFeeRatio));\n        }\n        if (!isExactInput) {\n            output = previewSwap(\n                base,\n                quote,\n                SwapParams({ isBaseToQuote: isBaseToQuote, isExactInput: true, feeRatio: feeRatio, amount: output })\n            );\n        }\n    }\n\n    function getMarkPriceX96(\n        uint256 base,\n        uint256 quote,\n        uint256 baseBalancePerShareX96\n    ) internal pure returns (uint256) {\n        return Math.mulDiv(getShareMarkPriceX96(base, quote), FixedPoint96.Q96, baseBalancePerShareX96);\n    }\n\n    function getShareMarkPriceX96(uint256 base, uint256 quote) internal pure returns (uint256) {\n        return Math.mulDiv(quote, FixedPoint96.Q96, base);\n    }\n\n    function getLiquidityDeleveraged(\n        uint256 poolCumBasePerLiquidityX96,\n        uint256 poolCumQuotePerLiquidityX96,\n        uint256 liquidity,\n        uint256 cumBasePerLiquidityX96,\n        uint256 cumQuotePerLiquidityX96\n    ) internal pure returns (int256, int256) {\n        int256 basePerLiquidityX96 = poolCumBasePerLiquidityX96.toInt256().sub(cumBasePerLiquidityX96.toInt256());\n        int256 quotePerLiquidityX96 = poolCumQuotePerLiquidityX96.toInt256().sub(cumQuotePerLiquidityX96.toInt256());\n\n        return (\n            liquidity.toInt256().mulDiv(basePerLiquidityX96, FixedPoint96.Q96),\n            liquidity.toInt256().mulDiv(quotePerLiquidityX96, FixedPoint96.Q96)\n        );\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/FundingLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { MarketStructs } from \"./MarketStructs.sol\";\nimport { IPerpdexPriceFeed } from \"../interfaces/IPerpdexPriceFeed.sol\";\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\n\nlibrary FundingLibrary {\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct ProcessFundingParams {\n        address priceFeedBase;\n        address priceFeedQuote;\n        uint256 markPriceX96;\n        uint24 maxPremiumRatio;\n        uint32 maxElapsedSec;\n        uint32 rolloverSec;\n    }\n\n    uint8 public constant MAX_DECIMALS = 77; // 10^MAX_DECIMALS < 2^256\n\n    function initializeFunding(MarketStructs.FundingInfo storage fundingInfo) internal {\n        fundingInfo.prevIndexPriceTimestamp = block.timestamp;\n    }\n\n    // must not revert even if priceFeed is malicious\n    function processFunding(MarketStructs.FundingInfo storage fundingInfo, ProcessFundingParams memory params)\n        internal\n        returns (\n            int256 fundingRateX96,\n            uint32 elapsedSec,\n            int256 premiumX96\n        )\n    {\n        uint256 currentTimestamp = block.timestamp;\n        uint256 elapsedSec256 = currentTimestamp.sub(fundingInfo.prevIndexPriceTimestamp);\n        if (elapsedSec256 == 0) return (0, 0, 0);\n\n        uint256 indexPriceBase = _getIndexPriceSafe(params.priceFeedBase);\n        uint256 indexPriceQuote = _getIndexPriceSafe(params.priceFeedQuote);\n        uint8 decimalsBase = _getDecimalsSafe(params.priceFeedBase);\n        uint8 decimalsQuote = _getDecimalsSafe(params.priceFeedQuote);\n        if (\n            (fundingInfo.prevIndexPriceBase == indexPriceBase && fundingInfo.prevIndexPriceQuote == indexPriceQuote) ||\n            indexPriceBase == 0 ||\n            indexPriceQuote == 0 ||\n            decimalsBase > MAX_DECIMALS ||\n            decimalsQuote > MAX_DECIMALS\n        ) {\n            return (0, 0, 0);\n        }\n\n        elapsedSec256 = Math.min(elapsedSec256, params.maxElapsedSec);\n        elapsedSec = elapsedSec256.toUint32();\n\n        premiumX96 = _calcPremiumX96(decimalsBase, decimalsQuote, indexPriceBase, indexPriceQuote, params.markPriceX96);\n\n        int256 maxPremiumX96 = FixedPoint96.Q96.mulRatio(params.maxPremiumRatio).toInt256();\n        premiumX96 = (-maxPremiumX96).max(maxPremiumX96.min(premiumX96));\n        fundingRateX96 = premiumX96.mulDiv(elapsedSec256.toInt256(), params.rolloverSec);\n\n        fundingInfo.prevIndexPriceBase = indexPriceBase;\n        fundingInfo.prevIndexPriceQuote = indexPriceQuote;\n        fundingInfo.prevIndexPriceTimestamp = currentTimestamp;\n    }\n\n    function validateInitialLiquidityPrice(\n        address priceFeedBase,\n        address priceFeedQuote,\n        uint256 base,\n        uint256 quote\n    ) internal view {\n        uint256 indexPriceBase = _getIndexPriceSafe(priceFeedBase);\n        uint256 indexPriceQuote = _getIndexPriceSafe(priceFeedQuote);\n        require(indexPriceBase > 0, \"FL_VILP: invalid base price\");\n        require(indexPriceQuote > 0, \"FL_VILP: invalid quote price\");\n        uint8 decimalsBase = _getDecimalsSafe(priceFeedBase);\n        uint8 decimalsQuote = _getDecimalsSafe(priceFeedQuote);\n        require(decimalsBase <= MAX_DECIMALS, \"FL_VILP: invalid base decimals\");\n        require(decimalsQuote <= MAX_DECIMALS, \"FL_VILP: invalid quote decimals\");\n\n        uint256 markPriceX96 = Math.mulDiv(quote, FixedPoint96.Q96, base);\n        int256 premiumX96 = _calcPremiumX96(decimalsBase, decimalsQuote, indexPriceBase, indexPriceQuote, markPriceX96);\n\n        require(premiumX96.abs() <= FixedPoint96.Q96.mulRatio(1e5), \"FL_VILP: too far from index\");\n    }\n\n    function _getIndexPriceSafe(address priceFeed) private view returns (uint256) {\n        if (priceFeed == address(0)) return 1; // indicate valid\n\n        bytes memory payload = abi.encodeWithSignature(\"getPrice()\");\n        (bool success, bytes memory data) = address(priceFeed).staticcall(payload);\n        if (!success) return 0; // invalid\n\n        return abi.decode(data, (uint256));\n    }\n\n    function _getDecimalsSafe(address priceFeed) private view returns (uint8) {\n        if (priceFeed == address(0)) return 0; // indicate valid\n\n        bytes memory payload = abi.encodeWithSignature(\"decimals()\");\n        (bool success, bytes memory data) = address(priceFeed).staticcall(payload);\n        if (!success) return 255; // invalid\n\n        return abi.decode(data, (uint8));\n    }\n\n    // TODO: must not revert\n    function _calcPremiumX96(\n        uint8 decimalsBase,\n        uint8 decimalsQuote,\n        uint256 indexPriceBase,\n        uint256 indexPriceQuote,\n        uint256 markPriceX96\n    ) private pure returns (int256 premiumX96) {\n        uint256 priceRatioX96 = markPriceX96;\n\n        if (decimalsBase != 0 || indexPriceBase != 1) {\n            priceRatioX96 = Math.mulDiv(priceRatioX96, 10**decimalsBase, indexPriceBase);\n        }\n        if (decimalsQuote != 0 || indexPriceQuote != 1) {\n            priceRatioX96 = Math.mulDiv(priceRatioX96, indexPriceQuote, 10**decimalsQuote);\n        }\n\n        premiumX96 = priceRatioX96.toInt256().sub(FixedPoint96.Q96.toInt256());\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/interfaces/IPerpdexPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\n\ninterface IPerpdexPriceFeed {\n    function decimals() external view returns (uint8);\n\n    /// @dev Returns the index price of the token.\n    function getPrice() external view returns (uint256);\n}\n"
    },
    "deps/perpdex-contract/contracts/lib/MakerLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { FixedPoint96 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport { PerpMath } from \"./PerpMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IPerpdexMarketMinimum } from \"../interfaces/IPerpdexMarketMinimum.sol\";\nimport { PerpdexStructs } from \"./PerpdexStructs.sol\";\nimport { AccountLibrary } from \"./AccountLibrary.sol\";\nimport { TakerLibrary } from \"./TakerLibrary.sol\";\n\nlibrary MakerLibrary {\n    using PerpMath for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct AddLiquidityParams {\n        address market;\n        uint256 base;\n        uint256 quote;\n        uint256 minBase;\n        uint256 minQuote;\n        uint24 imRatio;\n        uint8 maxMarketsPerAccount;\n    }\n\n    struct AddLiquidityResponse {\n        uint256 base;\n        uint256 quote;\n        uint256 liquidity;\n    }\n\n    struct RemoveLiquidityParams {\n        address market;\n        uint256 liquidity;\n        uint256 minBase;\n        uint256 minQuote;\n        uint24 mmRatio;\n        uint8 maxMarketsPerAccount;\n        bool isSelf;\n    }\n\n    struct RemoveLiquidityResponse {\n        uint256 base;\n        uint256 quote;\n        int256 takerBase;\n        int256 takerQuote;\n        int256 realizedPnl;\n        bool isLiquidation;\n    }\n\n    function addLiquidity(PerpdexStructs.AccountInfo storage accountInfo, AddLiquidityParams memory params)\n        internal\n        returns (AddLiquidityResponse memory response)\n    {\n        PerpdexStructs.MakerInfo storage makerInfo = accountInfo.makerInfos[params.market];\n\n        // retrieve before addLiquidity\n        (uint256 cumBasePerLiquidityX96, uint256 cumQuotePerLiquidityX96) =\n            IPerpdexMarketMinimum(params.market).getCumDeleveragedPerLiquidityX96();\n\n        (response.base, response.quote, response.liquidity) = IPerpdexMarketMinimum(params.market).addLiquidity(\n            params.base,\n            params.quote\n        );\n\n        require(response.base >= params.minBase, \"ML_AL: too small output base\");\n        require(response.quote >= params.minQuote, \"ML_AL: too small output quote\");\n\n        uint256 liquidityBefore = makerInfo.liquidity;\n        makerInfo.liquidity = liquidityBefore.add(response.liquidity);\n        {\n            makerInfo.cumBaseSharePerLiquidityX96 = _blendCumPerLiquidity(\n                liquidityBefore,\n                response.liquidity,\n                response.base,\n                makerInfo.cumBaseSharePerLiquidityX96,\n                cumBasePerLiquidityX96\n            );\n            makerInfo.cumQuotePerLiquidityX96 = _blendCumPerLiquidity(\n                liquidityBefore,\n                response.liquidity,\n                response.quote,\n                makerInfo.cumQuotePerLiquidityX96,\n                cumQuotePerLiquidityX96\n            );\n        }\n\n        AccountLibrary.updateMarkets(accountInfo, params.market, params.maxMarketsPerAccount);\n\n        require(AccountLibrary.hasEnoughInitialMargin(accountInfo, params.imRatio), \"ML_AL: not enough im\");\n    }\n\n    // difficult to calculate without error\n    // underestimate the value to maintain the liquidation free condition\n    // the error will be a burden to the insurance fund\n    // the error is much smaller than the gas fee, so it is impossible to attack\n    function _blendCumPerLiquidity(\n        uint256 liquidityBefore,\n        uint256 addedLiquidity,\n        uint256 addedToken,\n        uint256 cumBefore,\n        uint256 cumAfter\n    ) private pure returns (uint256) {\n        uint256 liquidityAfter = liquidityBefore.add(addedLiquidity);\n        cumAfter = cumAfter.add(Math.mulDiv(addedToken, FixedPoint96.Q96, addedLiquidity));\n\n        return\n            Math.mulDiv(cumBefore, liquidityBefore, liquidityAfter).add(\n                Math.mulDiv(cumAfter, addedLiquidity, liquidityAfter)\n            );\n    }\n\n    function removeLiquidity(PerpdexStructs.AccountInfo storage accountInfo, RemoveLiquidityParams memory params)\n        internal\n        returns (RemoveLiquidityResponse memory response)\n    {\n        response.isLiquidation = !AccountLibrary.hasEnoughMaintenanceMargin(accountInfo, params.mmRatio);\n\n        if (!params.isSelf) {\n            require(response.isLiquidation, \"ML_RL: enough mm\");\n        }\n\n        uint256 shareMarkPriceBeforeX96;\n        {\n            PerpdexStructs.MakerInfo storage makerInfo = accountInfo.makerInfos[params.market];\n            // retrieve before removeLiquidity\n            (response.takerBase, response.takerQuote) = IPerpdexMarketMinimum(params.market).getLiquidityDeleveraged(\n                params.liquidity,\n                makerInfo.cumBaseSharePerLiquidityX96,\n                makerInfo.cumQuotePerLiquidityX96\n            );\n\n            shareMarkPriceBeforeX96 = IPerpdexMarketMinimum(params.market).getShareMarkPriceX96();\n        }\n\n        {\n            (response.base, response.quote) = IPerpdexMarketMinimum(params.market).removeLiquidity(params.liquidity);\n\n            require(response.base >= params.minBase, \"ML_RL: too small output base\");\n            require(response.quote >= params.minQuote, \"ML_RL: too small output base\");\n\n            response.takerBase = response.takerBase.add(response.base.toInt256());\n            response.takerQuote = response.takerQuote.add(response.quote.toInt256());\n\n            PerpdexStructs.MakerInfo storage makerInfo = accountInfo.makerInfos[params.market];\n            makerInfo.liquidity = makerInfo.liquidity.sub(params.liquidity);\n        }\n\n        {\n            int256 takerQuoteCalculatedAtCurrentPrice =\n                -response.takerBase.mulDiv(shareMarkPriceBeforeX96.toInt256(), FixedPoint96.Q96);\n\n            // AccountLibrary.updateMarkets called\n            response.realizedPnl = TakerLibrary.addToTakerBalance(\n                accountInfo,\n                params.market,\n                response.takerBase,\n                takerQuoteCalculatedAtCurrentPrice,\n                response.takerQuote.sub(takerQuoteCalculatedAtCurrentPrice),\n                params.maxMarketsPerAccount\n            );\n        }\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/PerpdexMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { Multicall } from \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport { IPerpdexMarket } from \"./interfaces/IPerpdexMarket.sol\";\nimport { MarketStructs } from \"./lib/MarketStructs.sol\";\nimport { FundingLibrary } from \"./lib/FundingLibrary.sol\";\nimport { PoolLibrary } from \"./lib/PoolLibrary.sol\";\nimport { PriceLimitLibrary } from \"./lib/PriceLimitLibrary.sol\";\nimport { OrderBookLibrary } from \"./lib/OrderBookLibrary.sol\";\nimport { PoolFeeLibrary } from \"./lib/PoolFeeLibrary.sol\";\n\ncontract PerpdexMarket is IPerpdexMarket, ReentrancyGuard, Ownable, Multicall {\n    using Address for address;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    event PoolFeeConfigChanged(uint24 fixedFeeRatio, uint24 atrFeeRatio, uint32 atrEmaBlocks);\n    event FundingMaxPremiumRatioChanged(uint24 value);\n    event FundingMaxElapsedSecChanged(uint32 value);\n    event FundingRolloverSecChanged(uint32 value);\n    event PriceLimitConfigChanged(\n        uint24 normalOrderRatio,\n        uint24 liquidationRatio,\n        uint24 emaNormalOrderRatio,\n        uint24 emaLiquidationRatio,\n        uint32 emaSec\n    );\n\n    string public symbol;\n    address public immutable exchange;\n    address public immutable priceFeedBase;\n    address public immutable priceFeedQuote;\n\n    MarketStructs.PoolInfo public poolInfo;\n    MarketStructs.FundingInfo public fundingInfo;\n    MarketStructs.PriceLimitInfo public priceLimitInfo;\n    MarketStructs.OrderBookInfo internal _orderBookInfo;\n    MarketStructs.PoolFeeInfo public poolFeeInfo;\n\n    uint24 public fundingMaxPremiumRatio = 1e4;\n    uint32 public fundingMaxElapsedSec = 1 days;\n    uint32 public fundingRolloverSec = 1 days;\n    MarketStructs.PriceLimitConfig public priceLimitConfig =\n        MarketStructs.PriceLimitConfig({\n            normalOrderRatio: 5e4,\n            liquidationRatio: 10e4,\n            emaNormalOrderRatio: 20e4,\n            emaLiquidationRatio: 25e4,\n            emaSec: 5 minutes\n        });\n    MarketStructs.PoolFeeConfig public poolFeeConfig =\n        MarketStructs.PoolFeeConfig({ fixedFeeRatio: 0, atrFeeRatio: 4e6, atrEmaBlocks: 16 });\n\n    modifier onlyExchange() {\n        _onlyExchange();\n        _;\n    }\n\n    constructor(\n        string memory symbolArg,\n        address exchangeArg,\n        address priceFeedBaseArg,\n        address priceFeedQuoteArg\n    ) {\n        require(priceFeedBaseArg == address(0) || priceFeedBaseArg.isContract(), \"PM_C: base price feed invalid\");\n        require(priceFeedQuoteArg == address(0) || priceFeedQuoteArg.isContract(), \"PM_C: quote price feed invalid\");\n\n        symbol = symbolArg;\n        exchange = exchangeArg;\n        priceFeedBase = priceFeedBaseArg;\n        priceFeedQuote = priceFeedQuoteArg;\n\n        FundingLibrary.initializeFunding(fundingInfo);\n        PoolLibrary.initializePool(poolInfo);\n    }\n\n    function swap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bool isLiquidation\n    ) external onlyExchange nonReentrant returns (SwapResponse memory response) {\n        (uint256 maxAmount, MarketStructs.PriceLimitInfo memory updated) =\n            _doMaxSwap(isBaseToQuote, isExactInput, isLiquidation, 0);\n        require(amount <= maxAmount, \"PM_S: too large amount\");\n\n        uint256 sharePriceBeforeX96 = getShareMarkPriceX96();\n\n        OrderBookLibrary.SwapResponse memory swapResponse =\n            OrderBookLibrary.swap(\n                _orderBookInfo,\n                OrderBookLibrary.PreviewSwapParams({\n                    isBaseToQuote: isBaseToQuote,\n                    isExactInput: isExactInput,\n                    amount: amount,\n                    baseBalancePerShareX96: poolInfo.baseBalancePerShareX96\n                }),\n                _poolMaxSwap,\n                _poolSwap\n            );\n        response = SwapResponse({\n            oppositeAmount: swapResponse.oppositeAmount,\n            basePartial: swapResponse.basePartial,\n            quotePartial: swapResponse.quotePartial,\n            partialOrderId: swapResponse.partialKey\n        });\n\n        PoolFeeLibrary.update(poolFeeInfo, poolFeeConfig.atrEmaBlocks, sharePriceBeforeX96, getShareMarkPriceX96());\n        PriceLimitLibrary.update(priceLimitInfo, updated);\n\n        emit Swapped(\n            isBaseToQuote,\n            isExactInput,\n            amount,\n            response.oppositeAmount,\n            swapResponse.fullLastKey,\n            response.partialOrderId,\n            response.basePartial,\n            response.quotePartial\n        );\n\n        _processFunding();\n    }\n\n    function _poolSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount\n    ) private returns (uint256) {\n        return\n            PoolLibrary.swap(\n                poolInfo,\n                PoolLibrary.SwapParams({\n                    isBaseToQuote: isBaseToQuote,\n                    isExactInput: isExactInput,\n                    amount: amount,\n                    feeRatio: feeRatio()\n                })\n            );\n    }\n\n    function addLiquidity(uint256 baseShare, uint256 quoteBalance)\n        external\n        onlyExchange\n        nonReentrant\n        returns (\n            uint256 base,\n            uint256 quote,\n            uint256 liquidity\n        )\n    {\n        if (poolInfo.totalLiquidity == 0) {\n            FundingLibrary.validateInitialLiquidityPrice(priceFeedBase, priceFeedQuote, baseShare, quoteBalance);\n        }\n\n        (base, quote, liquidity) = PoolLibrary.addLiquidity(\n            poolInfo,\n            PoolLibrary.AddLiquidityParams({ base: baseShare, quote: quoteBalance })\n        );\n        emit LiquidityAdded(base, quote, liquidity);\n    }\n\n    function removeLiquidity(uint256 liquidity)\n        external\n        onlyExchange\n        nonReentrant\n        returns (uint256 base, uint256 quote)\n    {\n        (base, quote) = PoolLibrary.removeLiquidity(\n            poolInfo,\n            PoolLibrary.RemoveLiquidityParams({ liquidity: liquidity })\n        );\n        emit LiquidityRemoved(base, quote, liquidity);\n    }\n\n    function createLimitOrder(\n        bool isBid,\n        uint256 base,\n        uint256 priceX96\n    ) external onlyExchange nonReentrant returns (uint40 orderId) {\n        if (isBid) {\n            require(priceX96 <= getAskPriceX96(), \"PM_CLO: post only bid\");\n        } else {\n            require(priceX96 >= getBidPriceX96(), \"PM_CLO: post only ask\");\n        }\n        orderId = OrderBookLibrary.createOrder(_orderBookInfo, isBid, base, priceX96);\n        emit LimitOrderCreated(isBid, base, priceX96, orderId);\n    }\n\n    function cancelLimitOrder(bool isBid, uint40 orderId) external onlyExchange nonReentrant {\n        OrderBookLibrary.cancelOrder(_orderBookInfo, isBid, orderId);\n        emit LimitOrderCanceled(isBid, orderId);\n    }\n\n    function setFundingMaxPremiumRatio(uint24 value) external onlyOwner nonReentrant {\n        require(value <= 1e5, \"PM_SFMPR: too large\");\n        fundingMaxPremiumRatio = value;\n        emit FundingMaxPremiumRatioChanged(value);\n    }\n\n    function setFundingMaxElapsedSec(uint32 value) external onlyOwner nonReentrant {\n        require(value <= 7 days, \"PM_SFMES: too large\");\n        fundingMaxElapsedSec = value;\n        emit FundingMaxElapsedSecChanged(value);\n    }\n\n    function setFundingRolloverSec(uint32 value) external onlyOwner nonReentrant {\n        require(value <= 7 days, \"PM_SFRS: too large\");\n        require(value >= 1 hours, \"PM_SFRS: too small\");\n        fundingRolloverSec = value;\n        emit FundingRolloverSecChanged(value);\n    }\n\n    function setPriceLimitConfig(MarketStructs.PriceLimitConfig calldata value) external onlyOwner nonReentrant {\n        require(value.liquidationRatio <= 5e5, \"PE_SPLC: too large liquidation\");\n        require(value.normalOrderRatio <= value.liquidationRatio, \"PE_SPLC: invalid\");\n        require(value.emaLiquidationRatio < 1e6, \"PE_SPLC: ema too large liq\");\n        require(value.emaNormalOrderRatio <= value.emaLiquidationRatio, \"PE_SPLC: ema invalid\");\n        priceLimitConfig = value;\n        emit PriceLimitConfigChanged(\n            value.normalOrderRatio,\n            value.liquidationRatio,\n            value.emaNormalOrderRatio,\n            value.emaLiquidationRatio,\n            value.emaSec\n        );\n    }\n\n    function setPoolFeeConfig(MarketStructs.PoolFeeConfig calldata value) external onlyOwner nonReentrant {\n        require(value.fixedFeeRatio <= 5e4, \"PM_SPFC: fixed fee too large\");\n        require(value.atrEmaBlocks <= 1e4, \"PM_SPFC: atr ema blocks too big\");\n        poolFeeConfig = value;\n        emit PoolFeeConfigChanged(value.fixedFeeRatio, value.atrFeeRatio, value.atrEmaBlocks);\n    }\n\n    function previewSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bool isLiquidation\n    ) external view returns (uint256 oppositeAmount) {\n        (uint256 maxAmount, ) = _doMaxSwap(isBaseToQuote, isExactInput, isLiquidation, 0);\n        require(amount <= maxAmount, \"PM_PS: too large amount\");\n\n        OrderBookLibrary.PreviewSwapResponse memory response =\n            OrderBookLibrary.previewSwap(\n                isBaseToQuote ? _orderBookInfo.bid : _orderBookInfo.ask,\n                OrderBookLibrary.PreviewSwapParams({\n                    isBaseToQuote: isBaseToQuote,\n                    isExactInput: isExactInput,\n                    amount: amount,\n                    baseBalancePerShareX96: poolInfo.baseBalancePerShareX96\n                }),\n                _poolMaxSwap\n            );\n\n        oppositeAmount = PoolLibrary.previewSwap(\n            poolInfo.base,\n            poolInfo.quote,\n            PoolLibrary.SwapParams({\n                isBaseToQuote: isBaseToQuote,\n                isExactInput: isExactInput,\n                amount: response.amountPool,\n                feeRatio: feeRatio()\n            })\n        );\n        bool isOppositeBase = isBaseToQuote != isExactInput;\n        if (isOppositeBase) {\n            oppositeAmount += response.baseFull + response.basePartial;\n        } else {\n            oppositeAmount += response.quoteFull + response.quotePartial;\n        }\n    }\n\n    function _poolMaxSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 sharePriceX96\n    ) private view returns (uint256) {\n        return\n            PoolLibrary.maxSwap(poolInfo.base, poolInfo.quote, isBaseToQuote, isExactInput, feeRatio(), sharePriceX96);\n    }\n\n    function maxSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        bool isLiquidation\n    ) external view returns (uint256 amount) {\n        (amount, ) = _doMaxSwap(isBaseToQuote, isExactInput, isLiquidation, 0);\n    }\n\n    function maxSwapByPrice(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 sharePriceX96\n    ) external view returns (uint256 amount) {\n        (amount, ) = _doMaxSwap(isBaseToQuote, isExactInput, false, sharePriceX96);\n    }\n\n    function getShareMarkPriceX96() public view returns (uint256) {\n        if (poolInfo.base == 0) return 0;\n        return PoolLibrary.getShareMarkPriceX96(poolInfo.base, poolInfo.quote);\n    }\n\n    function getLiquidityValue(uint256 liquidity) external view returns (uint256, uint256) {\n        return PoolLibrary.getLiquidityValue(poolInfo, liquidity);\n    }\n\n    function getLiquidityDeleveraged(\n        uint256 liquidity,\n        uint256 cumBasePerLiquidityX96,\n        uint256 cumQuotePerLiquidityX96\n    ) external view returns (int256, int256) {\n        return\n            PoolLibrary.getLiquidityDeleveraged(\n                poolInfo.cumBasePerLiquidityX96,\n                poolInfo.cumQuotePerLiquidityX96,\n                liquidity,\n                cumBasePerLiquidityX96,\n                cumQuotePerLiquidityX96\n            );\n    }\n\n    function getCumDeleveragedPerLiquidityX96() external view returns (uint256, uint256) {\n        return (poolInfo.cumBasePerLiquidityX96, poolInfo.cumQuotePerLiquidityX96);\n    }\n\n    function baseBalancePerShareX96() external view returns (uint256) {\n        return poolInfo.baseBalancePerShareX96;\n    }\n\n    function getMarkPriceX96() public view returns (uint256) {\n        if (poolInfo.base == 0) return 0;\n        return PoolLibrary.getMarkPriceX96(poolInfo.base, poolInfo.quote, poolInfo.baseBalancePerShareX96);\n    }\n\n    function getAskPriceX96() public view returns (uint256 result) {\n        result = PoolLibrary.getAskPriceX96(getMarkPriceX96(), feeRatio());\n        uint256 obPrice = OrderBookLibrary.getBestPriceX96(_orderBookInfo.ask);\n        if (obPrice != 0 && obPrice < result) {\n            result = obPrice;\n        }\n    }\n\n    function getBidPriceX96() public view returns (uint256 result) {\n        result = PoolLibrary.getBidPriceX96(getMarkPriceX96(), feeRatio());\n        uint256 obPrice = OrderBookLibrary.getBestPriceX96(_orderBookInfo.bid);\n        if (obPrice != 0 && obPrice > result) {\n            result = obPrice;\n        }\n    }\n\n    function getLimitOrderInfo(bool isBid, uint40 orderId) external view returns (uint256 base, uint256 priceX96) {\n        return OrderBookLibrary.getOrderInfo(_orderBookInfo, isBid, orderId);\n    }\n\n    function getLimitOrderExecution(bool isBid, uint40 orderId)\n        external\n        view\n        returns (\n            uint256 executionId,\n            uint256 executedBase,\n            uint256 executedQuote\n        )\n    {\n        return OrderBookLibrary.getOrderExecution(_orderBookInfo, isBid, orderId);\n    }\n\n    function _processFunding() internal {\n        uint256 markPriceX96 = getMarkPriceX96();\n        (int256 fundingRateX96, uint32 elapsedSec, int256 premiumX96) =\n            FundingLibrary.processFunding(\n                fundingInfo,\n                FundingLibrary.ProcessFundingParams({\n                    priceFeedBase: priceFeedBase,\n                    priceFeedQuote: priceFeedQuote,\n                    markPriceX96: markPriceX96,\n                    maxPremiumRatio: fundingMaxPremiumRatio,\n                    maxElapsedSec: fundingMaxElapsedSec,\n                    rolloverSec: fundingRolloverSec\n                })\n            );\n        if (fundingRateX96 == 0) return;\n\n        PoolLibrary.applyFunding(poolInfo, fundingRateX96);\n        emit FundingPaid(\n            fundingRateX96,\n            elapsedSec,\n            premiumX96,\n            markPriceX96,\n            poolInfo.cumBasePerLiquidityX96,\n            poolInfo.cumQuotePerLiquidityX96\n        );\n    }\n\n    function _doMaxSwap(\n        bool isBaseToQuote,\n        bool isExactInput,\n        bool isLiquidation,\n        uint256 sharePriceX96\n    ) private view returns (uint256 amount, MarketStructs.PriceLimitInfo memory updated) {\n        if (poolInfo.totalLiquidity == 0) return (0, updated);\n\n        if (sharePriceX96 == 0) {\n            uint256 sharePriceBeforeX96 = getShareMarkPriceX96();\n            updated = PriceLimitLibrary.updateDry(priceLimitInfo, priceLimitConfig, sharePriceBeforeX96);\n\n            sharePriceX96 = PriceLimitLibrary.priceBound(\n                updated.referencePrice,\n                updated.emaPrice,\n                priceLimitConfig,\n                isLiquidation,\n                !isBaseToQuote\n            );\n        }\n\n        amount = PoolLibrary.maxSwap(\n            poolInfo.base,\n            poolInfo.quote,\n            isBaseToQuote,\n            isExactInput,\n            feeRatio(),\n            sharePriceX96\n        );\n\n        amount += OrderBookLibrary.maxSwap(\n            isBaseToQuote ? _orderBookInfo.bid : _orderBookInfo.ask,\n            isBaseToQuote,\n            isExactInput,\n            sharePriceX96,\n            poolInfo.baseBalancePerShareX96\n        );\n    }\n\n    function feeRatio() public view returns (uint24) {\n        return\n            Math\n                .min(priceLimitConfig.normalOrderRatio / 2, PoolFeeLibrary.feeRatio(poolFeeInfo, poolFeeConfig))\n                .toUint24();\n    }\n\n    // to reduce contract size\n    function _onlyExchange() private view {\n        require(exchange == msg.sender, \"PM_OE: caller is not exchange\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "deps/perpdex-contract/contracts/PerpdexExchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Multicall } from \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport { IPerpdexExchange } from \"./interfaces/IPerpdexExchange.sol\";\nimport { IPerpdexMarketMinimum } from \"./interfaces/IPerpdexMarketMinimum.sol\";\nimport { PerpdexStructs } from \"./lib/PerpdexStructs.sol\";\nimport { AccountLibrary } from \"./lib/AccountLibrary.sol\";\nimport { MakerLibrary } from \"./lib/MakerLibrary.sol\";\nimport { MakerOrderBookLibrary } from \"./lib/MakerOrderBookLibrary.sol\";\nimport { TakerLibrary } from \"./lib/TakerLibrary.sol\";\nimport { VaultLibrary } from \"./lib/VaultLibrary.sol\";\nimport { PerpMath } from \"./lib/PerpMath.sol\";\n\ncontract PerpdexExchange is IPerpdexExchange, ReentrancyGuard, Ownable, Multicall {\n    using Address for address;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using SafeCast for uint256;\n\n    // states\n    // trader\n    mapping(address => PerpdexStructs.AccountInfo) public accountInfos;\n    PerpdexStructs.InsuranceFundInfo public insuranceFundInfo;\n    PerpdexStructs.ProtocolInfo public protocolInfo;\n    // market, isBid, orderId, trader\n    mapping(address => mapping(bool => mapping(uint40 => address))) public orderIdToTrader;\n\n    // config\n    address public immutable settlementToken;\n    uint8 public constant quoteDecimals = 18;\n    uint8 public maxMarketsPerAccount = 16;\n    uint8 public maxOrdersPerAccount = 40;\n    uint24 public imRatio = 10e4;\n    uint24 public mmRatio = 5e4;\n    uint24 public protocolFeeRatio = 0;\n    PerpdexStructs.LiquidationRewardConfig public liquidationRewardConfig =\n        PerpdexStructs.LiquidationRewardConfig({ rewardRatio: 20e4, smoothEmaTime: 100 });\n    mapping(address => bool) public isMarketAllowed;\n\n    modifier checkDeadline(uint256 deadline) {\n        _checkDeadline(deadline);\n        _;\n    }\n\n    modifier checkMarketAllowed(address market) {\n        _checkMarketAllowed(market);\n        _;\n    }\n\n    constructor(address settlementTokenArg) {\n        require(settlementTokenArg == address(0) || settlementTokenArg.isContract(), \"PE_C: token address invalid\");\n\n        settlementToken = settlementTokenArg;\n    }\n\n    function deposit(uint256 amount) external payable nonReentrant {\n        address trader = _msgSender();\n        _settleLimitOrders(trader);\n\n        uint256 compensation = VaultLibrary.compensate(accountInfos[trader], insuranceFundInfo);\n        if (compensation != 0) {\n            emit CollateralCompensated(trader, compensation);\n        }\n\n        if (settlementToken == address(0)) {\n            require(amount == 0, \"PE_D: amount not zero\");\n            VaultLibrary.depositEth(accountInfos[trader], msg.value);\n            emit Deposited(trader, msg.value);\n        } else {\n            require(msg.value == 0, \"PE_D: msg.value not zero\");\n            VaultLibrary.deposit(\n                accountInfos[trader],\n                VaultLibrary.DepositParams({ settlementToken: settlementToken, amount: amount, from: trader })\n            );\n            emit Deposited(trader, amount);\n        }\n    }\n\n    function withdraw(uint256 amount) external nonReentrant {\n        address payable trader = payable(_msgSender());\n        _settleLimitOrders(trader);\n\n        VaultLibrary.withdraw(\n            accountInfos[trader],\n            VaultLibrary.WithdrawParams({\n                settlementToken: settlementToken,\n                amount: amount,\n                to: trader,\n                imRatio: imRatio\n            })\n        );\n        emit Withdrawn(trader, amount);\n    }\n\n    function transferProtocolFee(uint256 amount) external onlyOwner nonReentrant {\n        address trader = _msgSender();\n        _settleLimitOrders(trader);\n        VaultLibrary.transferProtocolFee(accountInfos[trader], protocolInfo, amount);\n        emit ProtocolFeeTransferred(trader, amount);\n    }\n\n    function trade(TradeParams calldata params)\n        external\n        nonReentrant\n        checkDeadline(params.deadline)\n        checkMarketAllowed(params.market)\n        returns (uint256 oppositeAmount)\n    {\n        _settleLimitOrders(params.trader);\n        TakerLibrary.TradeResponse memory response = _doTrade(params);\n\n        if (response.rawResponse.partialOrderId != 0) {\n            address partialTrader =\n                orderIdToTrader[params.market][params.isBaseToQuote][response.rawResponse.partialOrderId];\n            int256 partialRealizedPnL =\n                MakerOrderBookLibrary.processPartialExecution(\n                    accountInfos[partialTrader],\n                    params.market,\n                    params.isBaseToQuote,\n                    maxMarketsPerAccount,\n                    response.rawResponse\n                );\n\n            emit PartiallyExecuted(\n                partialTrader,\n                params.market,\n                params.isBaseToQuote,\n                response.rawResponse.basePartial,\n                response.rawResponse.quotePartial,\n                partialRealizedPnL\n            );\n        }\n\n        uint256 baseBalancePerShareX96 = IPerpdexMarketMinimum(params.market).baseBalancePerShareX96();\n        uint256 shareMarkPriceAfterX96 = IPerpdexMarketMinimum(params.market).getShareMarkPriceX96();\n\n        if (response.isLiquidation) {\n            emit PositionLiquidated(\n                params.trader,\n                params.market,\n                _msgSender(),\n                response.base,\n                response.quote,\n                response.realizedPnl,\n                response.protocolFee,\n                baseBalancePerShareX96,\n                shareMarkPriceAfterX96,\n                response.liquidationPenalty,\n                response.liquidationReward,\n                response.insuranceFundReward\n            );\n        } else {\n            emit PositionChanged(\n                params.trader,\n                params.market,\n                response.base,\n                response.quote,\n                response.realizedPnl,\n                response.protocolFee,\n                baseBalancePerShareX96,\n                shareMarkPriceAfterX96\n            );\n        }\n\n        oppositeAmount = params.isExactInput == params.isBaseToQuote ? response.quote.abs() : response.base.abs();\n    }\n\n    function addLiquidity(AddLiquidityParams calldata params)\n        external\n        nonReentrant\n        checkDeadline(params.deadline)\n        checkMarketAllowed(params.market)\n        returns (\n            uint256 base,\n            uint256 quote,\n            uint256 liquidity\n        )\n    {\n        address trader = _msgSender();\n        _settleLimitOrders(trader);\n\n        MakerLibrary.AddLiquidityResponse memory response =\n            MakerLibrary.addLiquidity(\n                accountInfos[trader],\n                MakerLibrary.AddLiquidityParams({\n                    market: params.market,\n                    base: params.base,\n                    quote: params.quote,\n                    minBase: params.minBase,\n                    minQuote: params.minQuote,\n                    imRatio: imRatio,\n                    maxMarketsPerAccount: maxMarketsPerAccount\n                })\n            );\n\n        PerpdexStructs.MakerInfo storage makerInfo = accountInfos[trader].makerInfos[params.market];\n        emit LiquidityAdded(\n            trader,\n            params.market,\n            response.base,\n            response.quote,\n            response.liquidity,\n            makerInfo.cumBaseSharePerLiquidityX96,\n            makerInfo.cumQuotePerLiquidityX96\n        );\n\n        return (response.base, response.quote, response.liquidity);\n    }\n\n    function removeLiquidity(RemoveLiquidityParams calldata params)\n        external\n        nonReentrant\n        checkDeadline(params.deadline)\n        checkMarketAllowed(params.market)\n        returns (uint256 base, uint256 quote)\n    {\n        _settleLimitOrders(params.trader);\n\n        MakerLibrary.RemoveLiquidityResponse memory response =\n            MakerLibrary.removeLiquidity(\n                accountInfos[params.trader],\n                MakerLibrary.RemoveLiquidityParams({\n                    market: params.market,\n                    liquidity: params.liquidity,\n                    minBase: params.minBase,\n                    minQuote: params.minQuote,\n                    isSelf: params.trader == _msgSender(),\n                    mmRatio: mmRatio,\n                    maxMarketsPerAccount: maxMarketsPerAccount\n                })\n            );\n\n        emit LiquidityRemoved(\n            params.trader,\n            params.market,\n            response.isLiquidation ? _msgSender() : address(0),\n            response.base,\n            response.quote,\n            params.liquidity,\n            response.takerBase,\n            response.takerQuote,\n            response.realizedPnl\n        );\n\n        return (response.base, response.quote);\n    }\n\n    function createLimitOrder(CreateLimitOrderParams calldata params)\n        external\n        nonReentrant\n        checkDeadline(params.deadline)\n        checkMarketAllowed(params.market)\n        returns (uint40 orderId)\n    {\n        address trader = _msgSender();\n        _settleLimitOrders(trader);\n\n        orderId = MakerOrderBookLibrary.createLimitOrder(\n            accountInfos[trader],\n            MakerOrderBookLibrary.CreateLimitOrderParams({\n                market: params.market,\n                isBid: params.isBid,\n                base: params.base,\n                priceX96: params.priceX96,\n                imRatio: imRatio,\n                maxMarketsPerAccount: maxMarketsPerAccount,\n                maxOrdersPerAccount: maxOrdersPerAccount\n            })\n        );\n        orderIdToTrader[params.market][params.isBid][orderId] = trader;\n\n        emit LimitOrderCreated(trader, params.market, params.isBid, params.base, params.priceX96, orderId);\n    }\n\n    function cancelLimitOrder(CancelLimitOrderParams calldata params)\n        external\n        nonReentrant\n        checkDeadline(params.deadline)\n        checkMarketAllowed(params.market)\n    {\n        address trader = orderIdToTrader[params.market][params.isBid][params.orderId];\n        require(trader != address(0), \"PE_CLO: order not exist\");\n        _settleLimitOrders(trader);\n\n        bool isLiquidation =\n            MakerOrderBookLibrary.cancelLimitOrder(\n                accountInfos[trader],\n                MakerOrderBookLibrary.CancelLimitOrderParams({\n                    market: params.market,\n                    isBid: params.isBid,\n                    orderId: params.orderId,\n                    isSelf: trader == _msgSender(),\n                    mmRatio: mmRatio,\n                    maxMarketsPerAccount: maxMarketsPerAccount\n                })\n            );\n\n        emit LimitOrderCanceled(\n            trader,\n            params.market,\n            isLiquidation ? _msgSender() : address(0),\n            params.isBid,\n            params.orderId\n        );\n    }\n\n    function _settleLimitOrders(address trader) internal {\n        MakerOrderBookLibrary.settleLimitOrdersAll(accountInfos[trader], maxMarketsPerAccount);\n    }\n\n    function setMaxMarketsPerAccount(uint8 value) external onlyOwner nonReentrant {\n        maxMarketsPerAccount = value;\n        emit MaxMarketsPerAccountChanged(value);\n    }\n\n    function setMaxOrdersPerAccount(uint8 value) external onlyOwner nonReentrant {\n        maxOrdersPerAccount = value;\n        emit MaxOrdersPerAccountChanged(value);\n    }\n\n    function setImRatio(uint24 value) external onlyOwner nonReentrant {\n        require(value < 1e6, \"PE_SIR: too large\");\n        require(value >= mmRatio, \"PE_SIR: smaller than mmRatio\");\n        imRatio = value;\n        emit ImRatioChanged(value);\n    }\n\n    function setMmRatio(uint24 value) external onlyOwner nonReentrant {\n        require(value <= imRatio, \"PE_SMR: bigger than imRatio\");\n        require(value > 0, \"PE_SMR: zero\");\n        mmRatio = value;\n        emit MmRatioChanged(value);\n    }\n\n    function setLiquidationRewardConfig(PerpdexStructs.LiquidationRewardConfig calldata value)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(value.rewardRatio < 1e6, \"PE_SLRC: too large reward ratio\");\n        require(value.smoothEmaTime > 0, \"PE_SLRC: ema time is zero\");\n        liquidationRewardConfig = value;\n        emit LiquidationRewardConfigChanged(value.rewardRatio, value.smoothEmaTime);\n    }\n\n    function setProtocolFeeRatio(uint24 value) external onlyOwner nonReentrant {\n        require(value <= 1e4, \"PE_SPFR: too large\");\n        protocolFeeRatio = value;\n        emit ProtocolFeeRatioChanged(value);\n    }\n\n    function setIsMarketAllowed(address market, bool value) external onlyOwner nonReentrant {\n        require(market.isContract(), \"PE_SIMA: market address invalid\");\n        if (value) {\n            require(IPerpdexMarketMinimum(market).exchange() == address(this), \"PE_SIMA: different exchange\");\n        }\n        isMarketAllowed[market] = value;\n        emit IsMarketAllowedChanged(market, value);\n    }\n\n    // all raw information can be retrieved through getters (including default getters)\n\n    function getTakerInfo(address trader, address market) external view returns (PerpdexStructs.TakerInfo memory) {\n        return accountInfos[trader].takerInfos[market];\n    }\n\n    function getMakerInfo(address trader, address market) external view returns (PerpdexStructs.MakerInfo memory) {\n        return accountInfos[trader].makerInfos[market];\n    }\n\n    function getAccountMarkets(address trader) external view returns (address[] memory) {\n        return accountInfos[trader].markets;\n    }\n\n    function getLimitOrderInfo(address trader, address market)\n        external\n        view\n        returns (\n            uint40 askRoot,\n            uint40 bidRoot,\n            uint256 totalBaseAsk,\n            uint256 totalBaseBid\n        )\n    {\n        PerpdexStructs.LimitOrderInfo storage info = accountInfos[trader].limitOrderInfos[market];\n        return (info.ask.root, info.bid.root, info.totalBaseAsk, info.totalBaseBid);\n    }\n\n    function getLimitOrderIds(\n        address trader,\n        address market,\n        bool isBid\n    ) external view returns (uint40[] memory) {\n        return MakerOrderBookLibrary.getLimitOrderIds(accountInfos[trader], market, isBid);\n    }\n\n    // dry run\n\n    function previewTrade(PreviewTradeParams calldata params)\n        external\n        view\n        checkMarketAllowed(params.market)\n        returns (uint256 oppositeAmount)\n    {\n        address trader = params.trader;\n        address caller = params.caller;\n\n        return\n            TakerLibrary.previewTrade(\n                accountInfos[trader],\n                TakerLibrary.PreviewTradeParams({\n                    market: params.market,\n                    isBaseToQuote: params.isBaseToQuote,\n                    isExactInput: params.isExactInput,\n                    amount: params.amount,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    mmRatio: mmRatio,\n                    protocolFeeRatio: protocolFeeRatio,\n                    isSelf: trader == caller\n                })\n            );\n    }\n\n    function maxTrade(MaxTradeParams calldata params) external view returns (uint256 amount) {\n        if (!isMarketAllowed[params.market]) return 0;\n\n        address trader = params.trader;\n        address caller = params.caller;\n\n        return\n            TakerLibrary.maxTrade({\n                accountInfo: accountInfos[trader],\n                market: params.market,\n                isBaseToQuote: params.isBaseToQuote,\n                isExactInput: params.isExactInput,\n                mmRatio: mmRatio,\n                protocolFeeRatio: protocolFeeRatio,\n                isSelf: trader == caller\n            });\n    }\n\n    // convenient getters\n\n    function getTakerInfoLazy(address trader, address market) external view returns (PerpdexStructs.TakerInfo memory) {\n        return AccountLibrary.getTakerInfo(accountInfos[trader], market);\n    }\n\n    function getCollateralBalance(address trader) external view returns (int256) {\n        return AccountLibrary.getCollateralBalance(accountInfos[trader]);\n    }\n\n    function getTotalAccountValue(address trader) external view returns (int256) {\n        return AccountLibrary.getTotalAccountValue(accountInfos[trader]);\n    }\n\n    function getPositionShare(address trader, address market) external view returns (int256) {\n        return AccountLibrary.getPositionShare(accountInfos[trader], market);\n    }\n\n    function getPositionNotional(address trader, address market) external view returns (int256) {\n        return AccountLibrary.getPositionNotional(accountInfos[trader], market);\n    }\n\n    function getTotalPositionNotional(address trader) external view returns (uint256) {\n        return AccountLibrary.getTotalPositionNotional(accountInfos[trader]);\n    }\n\n    function getOpenPositionShare(address trader, address market) external view returns (uint256) {\n        return AccountLibrary.getOpenPositionShare(accountInfos[trader], market);\n    }\n\n    function getOpenPositionNotional(address trader, address market) external view returns (uint256) {\n        return AccountLibrary.getOpenPositionNotional(accountInfos[trader], market);\n    }\n\n    function getTotalOpenPositionNotional(address trader) external view returns (uint256) {\n        return AccountLibrary.getTotalOpenPositionNotional(accountInfos[trader]);\n    }\n\n    function hasEnoughMaintenanceMargin(address trader) external view returns (bool) {\n        return AccountLibrary.hasEnoughMaintenanceMargin(accountInfos[trader], mmRatio);\n    }\n\n    function hasEnoughInitialMargin(address trader) external view returns (bool) {\n        return AccountLibrary.hasEnoughInitialMargin(accountInfos[trader], imRatio);\n    }\n\n    function isLiquidationFree(address trader) external view returns (bool) {\n        return AccountLibrary.isLiquidationFree(accountInfos[trader]);\n    }\n\n    // for avoiding stack too deep error\n    function _doTrade(TradeParams calldata params) private returns (TakerLibrary.TradeResponse memory) {\n        return\n            TakerLibrary.trade(\n                accountInfos[params.trader],\n                accountInfos[_msgSender()].vaultInfo,\n                insuranceFundInfo,\n                protocolInfo,\n                TakerLibrary.TradeParams({\n                    market: params.market,\n                    isBaseToQuote: params.isBaseToQuote,\n                    isExactInput: params.isExactInput,\n                    amount: params.amount,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    mmRatio: mmRatio,\n                    imRatio: imRatio,\n                    maxMarketsPerAccount: maxMarketsPerAccount,\n                    protocolFeeRatio: protocolFeeRatio,\n                    liquidationRewardConfig: liquidationRewardConfig,\n                    isSelf: params.trader == _msgSender()\n                })\n            );\n    }\n\n    // to reduce contract size\n    function _checkDeadline(uint256 deadline) private view {\n        require(block.timestamp <= deadline, \"PE_CD: too late\");\n    }\n\n    // to reduce contract size\n    function _checkMarketAllowed(address market) private view {\n        require(isMarketAllowed[market], \"PE_CMA: market not allowed\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract TestERC20 is ERC20PresetMinterPauser {\n    uint256 _transferFeeRatio;\n\n    uint8 private immutable _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimalsArg\n    ) ERC20PresetMinterPauser(name, symbol) {\n        _decimals = decimalsArg;\n        _transferFeeRatio = 0;\n    }\n\n    function approveForce(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        _approve(from, to, amount);\n    }\n\n    // WETH interface\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/test/TestPerpdexExchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { PerpdexExchange } from \"../../deps/perpdex-contract/contracts/PerpdexExchange.sol\";\nimport { PerpdexStructs } from \"../../deps/perpdex-contract/contracts/lib/PerpdexStructs.sol\";\n\ncontract TestPerpdexExchange is PerpdexExchange {\n    constructor(address settlementTokenArg) PerpdexExchange(settlementTokenArg) {}\n\n    function setAccountInfo(\n        address trader,\n        PerpdexStructs.VaultInfo memory vaultInfo,\n        address[] memory markets\n    ) external {\n        accountInfos[trader].vaultInfo = vaultInfo;\n        accountInfos[trader].markets = markets;\n    }\n}\n"
    },
    "contracts/PerpdexLongToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { PerpdexTokenBase } from \"./PerpdexTokenBase.sol\";\n\n// This class should be responsible for the high layers and not the low layers\n// Specifically, you should not rely directly on decimals, WETH, Perpdex\n// Let PerpdexTokenBase absorb those specifications\ncontract PerpdexLongToken is PerpdexTokenBase {\n    using SafeCast for int256;\n    using SafeMath for uint256;\n\n    constructor(\n        address marketArg,\n        address wethArg,\n        string memory nativeTokenSymbol\n    ) PerpdexTokenBase(marketArg, \"PerpDEX Long \", \"pl\", nativeTokenSymbol, wethArg) {}\n\n    function depositETH(address receiver) external payable onlyWeth nonReentrant returns (uint256) {\n        return _doDeposit(msg.value, receiver);\n    }\n\n    function deposit(uint256 assets, address receiver) external override nonReentrant returns (uint256 shares) {\n        _transferAssetFromSender(assets);\n        return _doDeposit(assets, receiver);\n    }\n\n    function _doDeposit(uint256 assets, address receiver) private returns (uint256 shares) {\n        _depositToPerpdex(assets);\n        shares = _trade(false, true, assets);\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mintETH(uint256 shares, address receiver) external payable onlyWeth nonReentrant returns (uint256 assets) {\n        assets = previewMint(shares);\n        uint256 exceeded = msg.value.sub(assets);\n        if (exceeded > 0) {\n            payable(msg.sender).transfer(exceeded);\n        }\n        _doMint(assets, shares, receiver);\n    }\n\n    function mint(uint256 shares, address receiver) external override nonReentrant returns (uint256 assets) {\n        assets = previewMint(shares);\n        _transferAssetFromSender(assets);\n        _doMint(assets, shares, receiver);\n    }\n\n    function _doMint(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) private {\n        _depositToPerpdex(assets);\n        uint256 oppositeAmount = _trade(false, false, shares);\n        require(oppositeAmount == assets, \"PLT_M: (never reach) ANFU\");\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdrawETH(\n        uint256 assets,\n        address payable receiver,\n        address owner\n    ) external onlyWeth nonReentrant returns (uint256 shares) {\n        shares = _trade(true, false, assets);\n        _doWithdraw(owner, receiver, shares, assets);\n        receiver.transfer(assets);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override nonReentrant returns (uint256 shares) {\n        shares = _trade(true, false, assets);\n        _doWithdraw(owner, receiver, shares, assets);\n        _transferAssetTo(receiver, assets);\n    }\n\n    function redeemETH(\n        uint256 shares,\n        address payable receiver,\n        address owner\n    ) external onlyWeth nonReentrant returns (uint256 assets) {\n        assets = _trade(true, true, shares);\n        _doWithdraw(owner, receiver, shares, assets);\n        receiver.transfer(assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override nonReentrant returns (uint256 assets) {\n        assets = _trade(true, true, shares);\n        _doWithdraw(owner, receiver, shares, assets);\n        _transferAssetTo(receiver, assets);\n    }\n\n    function previewDeposit(uint256 assets) external view override returns (uint256 shares) {\n        shares = _previewTrade(false, true, assets);\n    }\n\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        assets = _previewTrade(false, false, shares);\n    }\n\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        shares = _previewTrade(true, false, assets);\n    }\n\n    function previewRedeem(uint256 shares) external view override returns (uint256 assets) {\n        assets = _previewTrade(true, true, shares);\n    }\n\n    function maxDeposit(address) public view override returns (uint256 maxAssets) {\n        return _maxTrade(false, false);\n    }\n\n    function maxMint(address) public view override returns (uint256 maxShares) {\n        return _maxTrade(false, true);\n    }\n\n    function maxWithdraw(address owner) public view override returns (uint256 maxAssets) {\n        maxAssets = _maxTrade(true, true);\n        (bool success, uint256 previewAssets) = _tryPreviewTrade(true, true, balanceOf(owner));\n        if (success) {\n            maxAssets = Math.min(maxAssets, previewAssets);\n        }\n    }\n\n    function maxRedeem(address owner) public view override returns (uint256 maxShares) {\n        return Math.min(balanceOf(owner), _maxTrade(true, false));\n    }\n\n    function _doWithdraw(\n        address owner,\n        address receiver,\n        uint256 shares,\n        uint256 assets\n    ) private {\n        // check if msg.sender has allowance of owner's vault shares\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _burn(owner, shares);\n\n        // withdraw\n        _withdrawFromPerpdex(assets);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n}\n"
    },
    "contracts/test/TestPerpdexMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport { PerpdexMarket } from \"../../deps/perpdex-contract/contracts/PerpdexMarket.sol\";\nimport { MarketStructs } from \"../../deps/perpdex-contract/contracts/lib/MarketStructs.sol\";\n\ncontract TestPerpdexMarket is PerpdexMarket {\n    constructor(\n        string memory symbolArg,\n        address exchangeArg,\n        address priceFeedBaseArg,\n        address priceFeedQuoteArg\n    ) PerpdexMarket(symbolArg, exchangeArg, priceFeedBaseArg, priceFeedQuoteArg) {}\n\n    function setPoolInfo(MarketStructs.PoolInfo memory value) external {\n        poolInfo = value;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}